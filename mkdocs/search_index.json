{
    "docs": [
        {
            "location": "/",
            "text": "Tutorials \nfor Eclipse Vert.x\n\u00b6\n\n\nSimple tutorials to get you started\n\u00b6\n\n\nEclipse Vert.x is a tool-kit for building reactive applications on the JVM.\n\n\nEnjoy being a developer again.\n\n\nUnlike restrictive traditional application containers, Vert.x gives you incredible power and agility to create compelling, scalable, 21\nst\n century applications the way you want to, with a minimum of fuss, in the language you want.",
            "title": "Welcome"
        },
        {
            "location": "/#tutorials-for-eclipse-vertx",
            "text": "",
            "title": "Tutorials for Eclipse Vert.x"
        },
        {
            "location": "/#simple-tutorials-to-get-you-started",
            "text": "Eclipse Vert.x is a tool-kit for building reactive applications on the JVM.  Enjoy being a developer again.  Unlike restrictive traditional application containers, Vert.x gives you incredible power and agility to create compelling, scalable, 21 st  century applications the way you want to, with a minimum of fuss, in the language you want.",
            "title": "Simple tutorials to get you started"
        },
        {
            "location": "/tutorials/oauth2/github/",
            "text": "Basics of Authentication\n\u00b6\n\n\nIn this section, we're going to focus on the basics of authentication. Specifically, we're going to create a Java server (using \nvert.x\n) that implements the \nweb flow\n of an application in several different ways.\n\n\n\n\nNote\n\n\nYou can download the complete source code for this project from the \nvertx-examples\n repo.\n\n\n\n\nRegistering your app\n\u00b6\n\n\nFirst, you'll need to \nregister your application\n. Every registered OAuth application is assigned a unique Client ID and Client Secret. The Client Secret should not be shared! That includes checking the string into your repository.\n\n\nYou can fill out every piece of information however you like, except the \nAuthorization callback URL\n. This is easily the most important piece to setting up your application. It's the callback URL that GitHub returns the user to after successful authentication.\n\n\nSince we're running a regular Sinatra server, the location of the local instance is set to \nhttp://localhost:8080\n. Let's fill in the callback URL as \nhttp://localhost:8080/callback\n.\n\n\nAccepting user authorization\n\u00b6\n\n\nNow, let's start filling out our simple server. Create a class called \nio.acme.Server\n and paste this into it:\n\n\npackage\n \nio.acme\n;\n\n\n\nimport\n \nio.vertx.core.AbstractVerticle\n;\n\n\nimport\n \nio.vertx.core.json.JsonObject\n;\n\n\nimport\n \nio.vertx.ext.auth.oauth2.*\n;\n\n\nimport\n \nio.vertx.ext.auth.oauth2.providers.GithubAuth\n;\n\n\nimport\n \nio.vertx.ext.web.Router\n;\n\n\nimport\n \nio.vertx.ext.web.handler.*\n;\n\n\nimport\n \nio.vertx.ext.web.templ.HandlebarsTemplateEngine\n;\n\n\n\npublic\n \nclass\n \nServer\n \nextends\n \nAbstractVerticle\n \n{\n\n\n  \nprivate\n \nstatic\n \nfinal\n \nString\n \nCLIENT_ID\n \n=\n\n    \nSystem\n.\ngetEnv\n(\n\"GITHUB_CLIENT_ID\"\n);\n\n  \nprivate\n \nstatic\n \nfinal\n \nString\n \nCLIENT_SECRET\n \n=\n\n    \nSystem\n.\ngetEnv\n(\n\"GITHUB_CLIENT_SECRET\"\n);\n\n\n  \n// In order to use a template we first need to\n\n  \n// create an engine\n\n  \nprivate\n \nfinal\n \nHandlebarsTemplateEngine\n \nengine\n \n=\n\n    \nHandlebarsTemplateEngine\n.\ncreate\n();\n\n\n  \n@Override\n\n  \npublic\n \nvoid\n \nstart\n()\n \nthrows\n \nException\n \n{\n\n    \n// To simplify the development of the web components\n\n    \n// we use a Router to route all HTTP requests\n\n    \n// to organize our code in a reusable way.\n\n    \nfinal\n \nRouter\n \nrouter\n \n=\n \nRouter\n.\nrouter\n(\nvertx\n);\n\n    \n// we now protect the resource under the path \"/protected\"\n\n    \nrouter\n.\nroute\n(\n\"/protected\"\n).\nhandler\n(\n\n      \nOAuth2AuthHandler\n.\ncreate\n(\nauthProvider\n)\n\n        \n// for this resource we require that users have\n\n        \n// the authority to retrieve the user emails\n\n        \n.\naddAuthority\n(\n\"user:email\"\n)\n\n    \n);\n\n    \n// Entry point to the application, this will render\n\n    \n// a custom template.\n\n    \nrouter\n.\nget\n(\n\"/\"\n).\nhandler\n(\nctx\n \n->\n \n{\n\n      \n// we pass the client id to the template\n\n      \nctx\n.\nput\n(\n\"client_id\"\n,\n \nCLIENT_ID\n);\n\n      \n// and now delegate to the engine to render it.\n\n      \nengine\n.\nrender\n(\nctx\n,\n \n\"views\"\n,\n \n\"/index.hbs\"\n,\n \nres\n \n->\n \n{\n\n        \nif\n \n(\nres\n.\nsucceeded\n())\n \n{\n\n          \nctx\n.\nresponse\n()\n\n            \n.\nputHeader\n(\n\"Content-Type\"\n,\n \n\"text/html\"\n)\n\n            \n.\nend\n(\nres\n.\nresult\n());\n\n        \n}\n \nelse\n \n{\n\n          \nctx\n.\nfail\n(\nres\n.\ncause\n());\n\n        \n}\n\n      \n});\n\n    \n});\n\n    \n// The protected resource\n\n    \nrouter\n.\nget\n(\n\"/protected\"\n).\nhandler\n(\nctx\n \n->\n \n{\n\n      \nctx\n.\nresponse\n()\n\n        \n.\nend\n(\n\"Hello protected!\"\n);\n\n    \n});\n\n\n    \nvertx\n.\ncreateHttpServer\n()\n\n      \n.\nrequestHandler\n(\nrouter\n::\naccept\n)\n\n      \n.\nlisten\n(\n8080\n);\n\n  \n}\n\n\n}\n\n\n\n\n\nYour client ID and client secret keys come from \nyour application's configuration page\n. You should \nnever, ever\n store these values in GitHub--or any other public place, for that matter. We recommend storing them as \nenvironment variables\n -- which is exactly what we've done here.\n\n\nNotice that the protected resource uses the scope \nuser:email\n to define the scopes requested by the application. For our application, we're requesting \nuser:email\n scope for reading private email addresses.\n\n\nNext, in the \nproject resources\n create the template \nviews/index.hbs\n and paste this content:\n\n\n<html>\n  <body>\n    <p>\n      Well, hello there!\n    </p>\n    <p>\n      We're going to the protected resource, if there is no\n      user in the session we will talk to the GitHub API. Ready?\n      <a href=\"/protected\">Click here</a> to begin!</a>\n    </p>\n    <p>\n      <b>If that link doesn't work</b>, remember to provide\n      your own <a href=\"https://github.com/settings/applications/new\">\n      Client ID</a>!\n    </p>\n  </body>\n</html>\n\n\n\n\n(If you're unfamiliar with how \nHandlebars\n works, we recommend reading the \nHandlebars\n guide.)\n\n\nNavigate your browser to \nhttp://localhost:8080\n. After clicking on the link, you should be taken to GitHub, and presented with a dialog that looks something like this:\n\n\n\n\nIf you trust yourself, click \nAuthorize App\n. Wuh-oh! Vert.x spits out a 500 error (with the message \ncallback route is not configured\n). What gives?!\n\n\nWell, remember when we specified a Callback URL to be \ncallback\n? We didn't provide a route for it, so GitHub doesn't know where to drop the user after they authorize the app. Let's fix that now!\n\n\nProviding a callback\n\u00b6\n\n\nIn the \nServer\n class you don't need to know the internal of the OAuth2 protocol, the \nOAuth2AuthHandler\n can do it for if you configure the protection as:\n\n\nrouter\n.\nroute\n(\n\"/protected\"\n).\nhandler\n(\n\n  \nOAuth2AuthHandler\n.\ncreate\n(\nauthProvider\n)\n\n    \n// we now configure the oauth2 handler,\n\n    \n// it will setup the callback handler\n\n    \n// as expected by your oauth2 provider.\n\n    \n.\nsetupCallback\n(\nrouter\n.\nroute\n(\n\"/callback\"\n))\n\n    \n// for this resource we require that\n\n    \n// users have the authority to retrieve\n\n    \n// the user emails\n\n    \n.\naddAuthority\n(\n\"user:email\"\n));\n\n\n\n\n\nAfter a successful app authentication, GitHub provides a temporary \ncode\n value. This code is then \nPOST\ned back to GitHub in exchange for an \naccess_token\n which is in turn translated to a \nUser\n instance in your vert.x application. All this is taken care for you by the handler.\n\n\nChecking granted scopes\n\u00b6\n\n\nBefore the \nUser\n object is handled to you, if your handler was configured with \nauthorities\n they will be first checked. If they are not present then they the whole process is aborted with an \nAuthorization\n error.\n\n\nHowever you might want to assert for other granted authorities, in this case you would:\n\n\nctx\n.\nuser\n()\n\n  \n.\nisAuthorised\n(\n\"some:authority\"\n,\n \nres\n \n->\n \n{\n\n    \nif\n \n(\nres\n.\nfailed\n())\n \n{\n\n      \n// some error handling here...\n\n    \n}\n \nelse\n \n{\n\n      \nif\n \n(\nres\n.\nresult\n())\n \n{\n\n        \n// is authorized!\n\n      \n}\n \nelse\n \n{\n\n        \n// is not authorized!\n\n      \n}\n\n    \n}\n\n  \n});\n\n\n\n\n\nMaking authenticated request\n\u00b6\n\n\nAt last, with this access token, you'll be able to make authenticated requests as the logged in user:\n\n\n// we cast the user to a specialized implementation\n\n\nAccessToken\n \nuser\n \n=\n \n(\nAccessToken\n)\n \nctx\n.\nuser\n();\n\n\n// retrieve the user profile, this is a common feature\n\n\n// but not from the official OAuth2 spec\n\n\nuser\n.\nuserInfo\n(\nres\n \n->\n \n{\n\n  \nif\n \n(\nres\n.\nfailed\n())\n \n{\n\n    \n// request didn't succeed because the token was revoked so we\n\n    \n// invalidate the token stored in the session and render the\n\n    \n// index page so that the user can start the OAuth flow again\n\n    \nctx\n.\nsession\n().\ndestroy\n();\n\n    \nctx\n.\nfail\n(\nres\n.\ncause\n());\n\n    \nreturn\n;\n\n  \n}\n\n\n  \n// the request succeeded, so we use the API to fetch the user's emails\n\n  \nfinal\n \nJsonObject\n \nuserInfo\n \n=\n \nres\n.\nresult\n();\n\n\n  \n// fetch the user emails from the github API\n\n\n  \n// the fetch method will retrieve any resource and ensure the right\n\n  \n// secure headers are passed.\n\n  \nuser\n.\nfetch\n(\n\"https://api.github.com/user/emails\"\n,\n \nres2\n \n->\n \n{\n\n    \nif\n \n(\nres2\n.\nfailed\n())\n \n{\n\n      \nctx\n.\nsession\n().\ndestroy\n();\n\n      \nctx\n.\nfail\n(\nres\n.\ncause\n());\n\n      \nreturn\n;\n\n    \n}\n\n\n    \nuserInfo\n.\nput\n(\n\"private_emails\"\n,\n \nres2\n.\nresult\n().\njsonArray\n());\n\n    \n// we pass the client info to the template\n\n    \nctx\n.\nput\n(\n\"userInfo\"\n,\n \nuserInfo\n);\n\n    \n// and now delegate to the engine to render it.\n\n    \nengine\n.\nrender\n(\nctx\n,\n \n\"views\"\n,\n \n\"/advanced.hbs\"\n,\n \nres3\n \n->\n \n{\n\n      \nif\n \n(\nres3\n.\nsucceeded\n())\n \n{\n\n        \nctx\n.\nresponse\n()\n\n          \n.\nputHeader\n(\n\"Content-Type\"\n,\n \n\"text/html\"\n)\n\n          \n.\nend\n(\nres3\n.\nresult\n());\n\n      \n}\n \nelse\n \n{\n\n        \nctx\n.\nfail\n(\nres3\n.\ncause\n());\n\n      \n}\n\n    \n});\n\n  \n});\n\n\n});\n\n\n\n\n\nWe can do whatever we want with our results. In this case, we'll just dump them straight into \nadvanced.hbs\n:\n\n\n<html>\n<body>\n<p>Well, well, well, {{userInfo.login}}!</p>\n<p>\n  {{#if userInfo.email}} It looks like your public email\n  address is {{userInfo.email}}.\n  {{else}} It looks like you don't have a public email.\n  That's cool.\n  {{/if}}\n</p>\n<p>\n  {{#if userInfo.private_emails}}\n  With your permission, we were also able to dig up your\n  private email addresses:\n  {{#each userInfo.private_emails}}\n    {{email}}{{#unless @last}},{{/unless}}\n  {{/each}}\n  {{else}}\n  Also, you're a bit secretive about your private email\n  addresses.\n  {{/if}}\n</p>\n</body>\n</html>\n\n\n\n\nImplementing \"persistent\" authentication\n\u00b6\n\n\nIt'd be a pretty bad model if we required users to log into the app every single time they needed to access the web page. For example, try navigating directly to \nhttp://localhost:8080/protected\n. You'll get an authentication request over and over.\n\n\nWhat if we could circumvent the entire \"click here\" process, and just remember that, as long as the user's logged into GitHub, they should be able to access this application? Hold on to your hat, because that's \nexactly what we're going to do\n.\n\n\nOur little server above is rather simple. In order to wedge in some intelligent authentication, we're going to switch over to using sessions for storing tokens. This will make authentication transparent to the user.\n\n\nThis can be achived with the stock handlers so our server file would be:\n\n\npackage\n \nio.acme\n;\n\n\n\nimport\n \nio.vertx.core.AbstractVerticle\n;\n\n\nimport\n \nio.vertx.core.json.JsonObject\n;\n\n\nimport\n \nio.vertx.ext.auth.oauth2.AccessToken\n;\n\n\nimport\n \nio.vertx.ext.auth.oauth2.OAuth2Auth\n;\n\n\nimport\n \nio.vertx.ext.auth.oauth2.providers.GithubAuth\n;\n\n\nimport\n \nio.vertx.ext.web.Router\n;\n\n\nimport\n \nio.vertx.ext.web.handler.*\n;\n\n\nimport\n \nio.vertx.ext.web.sstore.LocalSessionStore\n;\n\n\nimport\n \nio.vertx.ext.web.templ.HandlebarsTemplateEngine\n;\n\n\n\npublic\n \nclass\n \nServer\n \nextends\n \nAbstractVerticle\n \n{\n\n\n  \nprivate\n \nstatic\n \nfinal\n \nString\n \nCLIENT_ID\n \n=\n\n    \nSystem\n.\ngetEnv\n(\n\"GITHUB_CLIENT_ID\"\n);\n\n  \nprivate\n \nstatic\n \nfinal\n \nString\n \nCLIENT_SECRET\n \n=\n\n    \nSystem\n.\ngetEnv\n(\n\"GITHUB_CLIENT_SECRET\"\n);\n\n\n  \n// In order to use a template we first need to\n\n  \n// create an engine\n\n  \nprivate\n \nfinal\n \nHandlebarsTemplateEngine\n \nengine\n \n=\n\n    \nHandlebarsTemplateEngine\n.\ncreate\n();\n\n\n  \n@Override\n\n  \npublic\n \nvoid\n \nstart\n()\n \nthrows\n \nException\n \n{\n\n    \n// To simplify the development of the web components\n\n    \n// we use a Router to route all HTTP requests\n\n    \n// to organize our code in a reusable way.\n\n    \nfinal\n \nRouter\n \nrouter\n \n=\n \nRouter\n.\nrouter\n(\nvertx\n);\n\n    \n// We need cookies and sessions\n\n    \nrouter\n.\nroute\n()\n\n      \n.\nhandler\n(\nCookieHandler\n.\ncreate\n());\n\n    \nrouter\n.\nroute\n()\n\n      \n.\nhandler\n(\nSessionHandler\n.\ncreate\n(\nLocalSessionStore\n.\ncreate\n(\nvertx\n)));\n\n    \n// Simple auth service which uses a GitHub to\n\n    \n// authenticate the user\n\n    \nOAuth2Auth\n \nauthProvider\n \n=\n\n      \nGithubAuth\n.\ncreate\n(\nvertx\n,\n \nCLIENT_ID\n,\n \nCLIENT_SECRET\n);\n\n    \n// We need a user session handler too to make sure\n\n    \n// the user is stored in the session between requests\n\n    \nrouter\n.\nroute\n()\n\n      \n.\nhandler\n(\nUserSessionHandler\n.\ncreate\n(\nauthProvider\n));\n\n    \n// we now protect the resource under the path \"/protected\"\n\n    \nrouter\n.\nroute\n(\n\"/protected\"\n).\nhandler\n(\n\n      \nOAuth2AuthHandler\n.\ncreate\n(\nauthProvider\n)\n\n        \n// we now configure the oauth2 handler, it will\n\n        \n// setup the callback handler\n\n        \n// as expected by your oauth2 provider.\n\n        \n.\nsetupCallback\n(\nrouter\n.\nroute\n(\n\"/callback\"\n))\n\n        \n// for this resource we require that users have\n\n        \n// the authority to retrieve the user emails\n\n        \n.\naddAuthority\n(\n\"user:email\"\n)\n\n    \n);\n\n    \n// Entry point to the application, this will render\n\n    \n// a custom template.\n\n    \nrouter\n.\nget\n(\n\"/\"\n).\nhandler\n(\nctx\n \n->\n \n{\n\n      \n// we pass the client id to the template\n\n      \nctx\n.\nput\n(\n\"client_id\"\n,\n \nCLIENT_ID\n);\n\n      \n// and now delegate to the engine to render it.\n\n      \nengine\n.\nrender\n(\nctx\n,\n \n\"views\"\n,\n \n\"/index.hbs\"\n,\n \nres\n \n->\n \n{\n\n        \nif\n \n(\nres\n.\nsucceeded\n())\n \n{\n\n          \nctx\n.\nresponse\n()\n\n            \n.\nputHeader\n(\n\"Content-Type\"\n,\n \n\"text/html\"\n)\n\n            \n.\nend\n(\nres\n.\nresult\n());\n\n        \n}\n \nelse\n \n{\n\n          \nctx\n.\nfail\n(\nres\n.\ncause\n());\n\n        \n}\n\n      \n});\n\n    \n});\n\n    \n// The protected resource\n\n    \nrouter\n.\nget\n(\n\"/protected\"\n).\nhandler\n(\nctx\n \n->\n \n{\n\n      \nAccessToken\n \nuser\n \n=\n \n(\nAccessToken\n)\n \nctx\n.\nuser\n();\n\n      \n// retrieve the user profile, this is a common\n\n      \n// feature but not from the official OAuth2 spec\n\n      \nuser\n.\nuserInfo\n(\nres\n \n->\n \n{\n\n        \nif\n \n(\nres\n.\nfailed\n())\n \n{\n\n          \n// request didn't succeed because the token\n\n          \n// was revoked so we invalidate the token stored\n\n          \n// in the session and render an error page\n\n          \n// so that the user can start the OAuth flow again\n\n          \nctx\n.\nsession\n().\ndestroy\n();\n\n          \nctx\n.\nfail\n(\nres\n.\ncause\n());\n\n        \n}\n \nelse\n \n{\n\n          \n// the request succeeded, so we use the API to\n\n          \n// fetch the user's emails\n\n          \nfinal\n \nJsonObject\n \nuserInfo\n \n=\n \nres\n.\nresult\n();\n\n\n          \n// fetch the user emails from the github API\n\n\n          \n// the fetch method will retrieve any resource and\n\n          \n// ensure the right secure headers are passed.\n\n          \nuser\n.\nfetch\n(\n\"https://api.github.com/user/emails\"\n,\n \nres2\n \n->\n \n{\n\n            \nif\n \n(\nres2\n.\nfailed\n())\n \n{\n\n              \n// request didn't succeed because the token\n\n              \n// was revoked so we invalidate the token stored\n\n              \n// in the session and render an error page\n\n              \n// so that the user can start the OAuth flow again\n\n              \nctx\n.\nsession\n().\ndestroy\n();\n\n              \nctx\n.\nfail\n(\nres2\n.\ncause\n());\n\n            \n}\n \nelse\n \n{\n\n              \nuserInfo\n.\nput\n(\n\"private_emails\"\n,\n \nres2\n.\nresult\n().\njsonArray\n());\n\n              \n// we pass the client info to the template\n\n              \nctx\n.\nput\n(\n\"userInfo\"\n,\n \nuserInfo\n);\n\n              \n// and now delegate to the engine to render it.\n\n              \nengine\n.\nrender\n(\nctx\n,\n \n\"views\"\n,\n \n\"/advanced.hbs\"\n,\n \nres3\n \n->\n \n{\n\n                \nif\n \n(\nres3\n.\nsucceeded\n())\n \n{\n\n                  \nctx\n.\nresponse\n()\n\n                    \n.\nputHeader\n(\n\"Content-Type\"\n,\n \n\"text/html\"\n)\n\n                    \n.\nend\n(\nres3\n.\nresult\n());\n\n                \n}\n \nelse\n \n{\n\n                  \nctx\n.\nfail\n(\nres3\n.\ncause\n());\n\n                \n}\n\n              \n});\n\n            \n}\n\n          \n});\n\n        \n}\n\n      \n});\n\n    \n});\n\n\n    \nvertx\n.\ncreateHttpServer\n().\nrequestHandler\n(\nrouter\n::\naccept\n).\nlisten\n(\n8080\n);\n\n  \n}\n\n\n}\n\n\n\n\n\nI hope you now can use OAuth2 on your next project!",
            "title": "Oauth2"
        },
        {
            "location": "/tutorials/oauth2/github/#basics-of-authentication",
            "text": "In this section, we're going to focus on the basics of authentication. Specifically, we're going to create a Java server (using  vert.x ) that implements the  web flow  of an application in several different ways.   Note  You can download the complete source code for this project from the  vertx-examples  repo.",
            "title": "Basics of Authentication"
        },
        {
            "location": "/tutorials/oauth2/github/#registering-your-app",
            "text": "First, you'll need to  register your application . Every registered OAuth application is assigned a unique Client ID and Client Secret. The Client Secret should not be shared! That includes checking the string into your repository.  You can fill out every piece of information however you like, except the  Authorization callback URL . This is easily the most important piece to setting up your application. It's the callback URL that GitHub returns the user to after successful authentication.  Since we're running a regular Sinatra server, the location of the local instance is set to  http://localhost:8080 . Let's fill in the callback URL as  http://localhost:8080/callback .",
            "title": "Registering your app"
        },
        {
            "location": "/tutorials/oauth2/github/#accepting-user-authorization",
            "text": "Now, let's start filling out our simple server. Create a class called  io.acme.Server  and paste this into it:  package   io.acme ;  import   io.vertx.core.AbstractVerticle ;  import   io.vertx.core.json.JsonObject ;  import   io.vertx.ext.auth.oauth2.* ;  import   io.vertx.ext.auth.oauth2.providers.GithubAuth ;  import   io.vertx.ext.web.Router ;  import   io.vertx.ext.web.handler.* ;  import   io.vertx.ext.web.templ.HandlebarsTemplateEngine ;  public   class   Server   extends   AbstractVerticle   { \n\n   private   static   final   String   CLIENT_ID   = \n     System . getEnv ( \"GITHUB_CLIENT_ID\" ); \n   private   static   final   String   CLIENT_SECRET   = \n     System . getEnv ( \"GITHUB_CLIENT_SECRET\" ); \n\n   // In order to use a template we first need to \n   // create an engine \n   private   final   HandlebarsTemplateEngine   engine   = \n     HandlebarsTemplateEngine . create (); \n\n   @Override \n   public   void   start ()   throws   Exception   { \n     // To simplify the development of the web components \n     // we use a Router to route all HTTP requests \n     // to organize our code in a reusable way. \n     final   Router   router   =   Router . router ( vertx ); \n     // we now protect the resource under the path \"/protected\" \n     router . route ( \"/protected\" ). handler ( \n       OAuth2AuthHandler . create ( authProvider ) \n         // for this resource we require that users have \n         // the authority to retrieve the user emails \n         . addAuthority ( \"user:email\" ) \n     ); \n     // Entry point to the application, this will render \n     // a custom template. \n     router . get ( \"/\" ). handler ( ctx   ->   { \n       // we pass the client id to the template \n       ctx . put ( \"client_id\" ,   CLIENT_ID ); \n       // and now delegate to the engine to render it. \n       engine . render ( ctx ,   \"views\" ,   \"/index.hbs\" ,   res   ->   { \n         if   ( res . succeeded ())   { \n           ctx . response () \n             . putHeader ( \"Content-Type\" ,   \"text/html\" ) \n             . end ( res . result ()); \n         }   else   { \n           ctx . fail ( res . cause ()); \n         } \n       }); \n     }); \n     // The protected resource \n     router . get ( \"/protected\" ). handler ( ctx   ->   { \n       ctx . response () \n         . end ( \"Hello protected!\" ); \n     }); \n\n     vertx . createHttpServer () \n       . requestHandler ( router :: accept ) \n       . listen ( 8080 ); \n   }  }   Your client ID and client secret keys come from  your application's configuration page . You should  never, ever  store these values in GitHub--or any other public place, for that matter. We recommend storing them as  environment variables  -- which is exactly what we've done here.  Notice that the protected resource uses the scope  user:email  to define the scopes requested by the application. For our application, we're requesting  user:email  scope for reading private email addresses.  Next, in the  project resources  create the template  views/index.hbs  and paste this content:  <html>\n  <body>\n    <p>\n      Well, hello there!\n    </p>\n    <p>\n      We're going to the protected resource, if there is no\n      user in the session we will talk to the GitHub API. Ready?\n      <a href=\"/protected\">Click here</a> to begin!</a>\n    </p>\n    <p>\n      <b>If that link doesn't work</b>, remember to provide\n      your own <a href=\"https://github.com/settings/applications/new\">\n      Client ID</a>!\n    </p>\n  </body>\n</html>  (If you're unfamiliar with how  Handlebars  works, we recommend reading the  Handlebars  guide.)  Navigate your browser to  http://localhost:8080 . After clicking on the link, you should be taken to GitHub, and presented with a dialog that looks something like this:   If you trust yourself, click  Authorize App . Wuh-oh! Vert.x spits out a 500 error (with the message  callback route is not configured ). What gives?!  Well, remember when we specified a Callback URL to be  callback ? We didn't provide a route for it, so GitHub doesn't know where to drop the user after they authorize the app. Let's fix that now!",
            "title": "Accepting user authorization"
        },
        {
            "location": "/tutorials/oauth2/github/#providing-a-callback",
            "text": "In the  Server  class you don't need to know the internal of the OAuth2 protocol, the  OAuth2AuthHandler  can do it for if you configure the protection as:  router . route ( \"/protected\" ). handler ( \n   OAuth2AuthHandler . create ( authProvider ) \n     // we now configure the oauth2 handler, \n     // it will setup the callback handler \n     // as expected by your oauth2 provider. \n     . setupCallback ( router . route ( \"/callback\" )) \n     // for this resource we require that \n     // users have the authority to retrieve \n     // the user emails \n     . addAuthority ( \"user:email\" ));   After a successful app authentication, GitHub provides a temporary  code  value. This code is then  POST ed back to GitHub in exchange for an  access_token  which is in turn translated to a  User  instance in your vert.x application. All this is taken care for you by the handler.",
            "title": "Providing a callback"
        },
        {
            "location": "/tutorials/oauth2/github/#checking-granted-scopes",
            "text": "Before the  User  object is handled to you, if your handler was configured with  authorities  they will be first checked. If they are not present then they the whole process is aborted with an  Authorization  error.  However you might want to assert for other granted authorities, in this case you would:  ctx . user () \n   . isAuthorised ( \"some:authority\" ,   res   ->   { \n     if   ( res . failed ())   { \n       // some error handling here... \n     }   else   { \n       if   ( res . result ())   { \n         // is authorized! \n       }   else   { \n         // is not authorized! \n       } \n     } \n   });",
            "title": "Checking granted scopes"
        },
        {
            "location": "/tutorials/oauth2/github/#making-authenticated-request",
            "text": "At last, with this access token, you'll be able to make authenticated requests as the logged in user:  // we cast the user to a specialized implementation  AccessToken   user   =   ( AccessToken )   ctx . user ();  // retrieve the user profile, this is a common feature  // but not from the official OAuth2 spec  user . userInfo ( res   ->   { \n   if   ( res . failed ())   { \n     // request didn't succeed because the token was revoked so we \n     // invalidate the token stored in the session and render the \n     // index page so that the user can start the OAuth flow again \n     ctx . session (). destroy (); \n     ctx . fail ( res . cause ()); \n     return ; \n   } \n\n   // the request succeeded, so we use the API to fetch the user's emails \n   final   JsonObject   userInfo   =   res . result (); \n\n   // fetch the user emails from the github API \n\n   // the fetch method will retrieve any resource and ensure the right \n   // secure headers are passed. \n   user . fetch ( \"https://api.github.com/user/emails\" ,   res2   ->   { \n     if   ( res2 . failed ())   { \n       ctx . session (). destroy (); \n       ctx . fail ( res . cause ()); \n       return ; \n     } \n\n     userInfo . put ( \"private_emails\" ,   res2 . result (). jsonArray ()); \n     // we pass the client info to the template \n     ctx . put ( \"userInfo\" ,   userInfo ); \n     // and now delegate to the engine to render it. \n     engine . render ( ctx ,   \"views\" ,   \"/advanced.hbs\" ,   res3   ->   { \n       if   ( res3 . succeeded ())   { \n         ctx . response () \n           . putHeader ( \"Content-Type\" ,   \"text/html\" ) \n           . end ( res3 . result ()); \n       }   else   { \n         ctx . fail ( res3 . cause ()); \n       } \n     }); \n   });  });   We can do whatever we want with our results. In this case, we'll just dump them straight into  advanced.hbs :  <html>\n<body>\n<p>Well, well, well, {{userInfo.login}}!</p>\n<p>\n  {{#if userInfo.email}} It looks like your public email\n  address is {{userInfo.email}}.\n  {{else}} It looks like you don't have a public email.\n  That's cool.\n  {{/if}}\n</p>\n<p>\n  {{#if userInfo.private_emails}}\n  With your permission, we were also able to dig up your\n  private email addresses:\n  {{#each userInfo.private_emails}}\n    {{email}}{{#unless @last}},{{/unless}}\n  {{/each}}\n  {{else}}\n  Also, you're a bit secretive about your private email\n  addresses.\n  {{/if}}\n</p>\n</body>\n</html>",
            "title": "Making authenticated request"
        },
        {
            "location": "/tutorials/oauth2/github/#implementing-persistent-authentication",
            "text": "It'd be a pretty bad model if we required users to log into the app every single time they needed to access the web page. For example, try navigating directly to  http://localhost:8080/protected . You'll get an authentication request over and over.  What if we could circumvent the entire \"click here\" process, and just remember that, as long as the user's logged into GitHub, they should be able to access this application? Hold on to your hat, because that's  exactly what we're going to do .  Our little server above is rather simple. In order to wedge in some intelligent authentication, we're going to switch over to using sessions for storing tokens. This will make authentication transparent to the user.  This can be achived with the stock handlers so our server file would be:  package   io.acme ;  import   io.vertx.core.AbstractVerticle ;  import   io.vertx.core.json.JsonObject ;  import   io.vertx.ext.auth.oauth2.AccessToken ;  import   io.vertx.ext.auth.oauth2.OAuth2Auth ;  import   io.vertx.ext.auth.oauth2.providers.GithubAuth ;  import   io.vertx.ext.web.Router ;  import   io.vertx.ext.web.handler.* ;  import   io.vertx.ext.web.sstore.LocalSessionStore ;  import   io.vertx.ext.web.templ.HandlebarsTemplateEngine ;  public   class   Server   extends   AbstractVerticle   { \n\n   private   static   final   String   CLIENT_ID   = \n     System . getEnv ( \"GITHUB_CLIENT_ID\" ); \n   private   static   final   String   CLIENT_SECRET   = \n     System . getEnv ( \"GITHUB_CLIENT_SECRET\" ); \n\n   // In order to use a template we first need to \n   // create an engine \n   private   final   HandlebarsTemplateEngine   engine   = \n     HandlebarsTemplateEngine . create (); \n\n   @Override \n   public   void   start ()   throws   Exception   { \n     // To simplify the development of the web components \n     // we use a Router to route all HTTP requests \n     // to organize our code in a reusable way. \n     final   Router   router   =   Router . router ( vertx ); \n     // We need cookies and sessions \n     router . route () \n       . handler ( CookieHandler . create ()); \n     router . route () \n       . handler ( SessionHandler . create ( LocalSessionStore . create ( vertx ))); \n     // Simple auth service which uses a GitHub to \n     // authenticate the user \n     OAuth2Auth   authProvider   = \n       GithubAuth . create ( vertx ,   CLIENT_ID ,   CLIENT_SECRET ); \n     // We need a user session handler too to make sure \n     // the user is stored in the session between requests \n     router . route () \n       . handler ( UserSessionHandler . create ( authProvider )); \n     // we now protect the resource under the path \"/protected\" \n     router . route ( \"/protected\" ). handler ( \n       OAuth2AuthHandler . create ( authProvider ) \n         // we now configure the oauth2 handler, it will \n         // setup the callback handler \n         // as expected by your oauth2 provider. \n         . setupCallback ( router . route ( \"/callback\" )) \n         // for this resource we require that users have \n         // the authority to retrieve the user emails \n         . addAuthority ( \"user:email\" ) \n     ); \n     // Entry point to the application, this will render \n     // a custom template. \n     router . get ( \"/\" ). handler ( ctx   ->   { \n       // we pass the client id to the template \n       ctx . put ( \"client_id\" ,   CLIENT_ID ); \n       // and now delegate to the engine to render it. \n       engine . render ( ctx ,   \"views\" ,   \"/index.hbs\" ,   res   ->   { \n         if   ( res . succeeded ())   { \n           ctx . response () \n             . putHeader ( \"Content-Type\" ,   \"text/html\" ) \n             . end ( res . result ()); \n         }   else   { \n           ctx . fail ( res . cause ()); \n         } \n       }); \n     }); \n     // The protected resource \n     router . get ( \"/protected\" ). handler ( ctx   ->   { \n       AccessToken   user   =   ( AccessToken )   ctx . user (); \n       // retrieve the user profile, this is a common \n       // feature but not from the official OAuth2 spec \n       user . userInfo ( res   ->   { \n         if   ( res . failed ())   { \n           // request didn't succeed because the token \n           // was revoked so we invalidate the token stored \n           // in the session and render an error page \n           // so that the user can start the OAuth flow again \n           ctx . session (). destroy (); \n           ctx . fail ( res . cause ()); \n         }   else   { \n           // the request succeeded, so we use the API to \n           // fetch the user's emails \n           final   JsonObject   userInfo   =   res . result (); \n\n           // fetch the user emails from the github API \n\n           // the fetch method will retrieve any resource and \n           // ensure the right secure headers are passed. \n           user . fetch ( \"https://api.github.com/user/emails\" ,   res2   ->   { \n             if   ( res2 . failed ())   { \n               // request didn't succeed because the token \n               // was revoked so we invalidate the token stored \n               // in the session and render an error page \n               // so that the user can start the OAuth flow again \n               ctx . session (). destroy (); \n               ctx . fail ( res2 . cause ()); \n             }   else   { \n               userInfo . put ( \"private_emails\" ,   res2 . result (). jsonArray ()); \n               // we pass the client info to the template \n               ctx . put ( \"userInfo\" ,   userInfo ); \n               // and now delegate to the engine to render it. \n               engine . render ( ctx ,   \"views\" ,   \"/advanced.hbs\" ,   res3   ->   { \n                 if   ( res3 . succeeded ())   { \n                   ctx . response () \n                     . putHeader ( \"Content-Type\" ,   \"text/html\" ) \n                     . end ( res3 . result ()); \n                 }   else   { \n                   ctx . fail ( res3 . cause ()); \n                 } \n               }); \n             } \n           }); \n         } \n       }); \n     }); \n\n     vertx . createHttpServer (). requestHandler ( router :: accept ). listen ( 8080 ); \n   }  }   I hope you now can use OAuth2 on your next project!",
            "title": "Implementing \"persistent\" authentication"
        },
        {
            "location": "/tips/web/workflow/",
            "text": "A Workflow for Modern Web Development\n\u00b6\n\n\nModern web development is more than just a HTTP server and generation of HTML on a request response workflow.\n\n\nThis would be the case in the old days of Servlet programming, nowadays we need to build complex single page applications with many resources and complex build steps.\n\n\nWith Vert.x we can define a workflow that is familiar both to backend developers and as well to frontend developers.\n\n\nA Backend web application\n\u00b6\n\n\nA typical backend application would be a server serving some content, for this one would use maven to build the application, your \npom.xml\n would look like:\n\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n\n<project\n \nxmlns=\n\"http://maven.apache.org/POM/4.0.0\"\n\n         \nxmlns:xsi=\n\"http://www.w3.org/2001/XMLSchema-instance\"\n\n         \nxsi:schemaLocation=\n\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\n>\n\n\n  \n<modelVersion>\n4.0.0\n</modelVersion>\n\n  \n<packaging>\njar\n</packaging>\n\n\n  \n<groupId>\ncom.example\n</groupId>\n\n  \n<artifactId>\ncom.example\n</artifactId>\n\n  \n<version>\n1.0.0\n</version>\n\n\n  \n<name>\nexample\n</name>\n\n\n  \n<dependencies>\n\n    \n<dependency>\n\n      \n<groupId>\nio.vertx\n</groupId>\n\n      \n<artifactId>\nvertx-web\n</artifactId>\n\n      \n<version>\n3.4.2\n</version>\n\n    \n</dependency>\n\n    \n<dependency>\n\n      \n<groupId>\nxyz.jetdrone\n</groupId>\n\n      \n<artifactId>\nhot-reload\n</artifactId>\n\n      \n<version>\n0.0.2\n</version>\n\n    \n</dependency>\n\n  \n</dependencies>\n\n\n  \n<build>\n\n    \n<pluginManagement>\n\n      \n<plugins>\n\n        \n<!-- We specify the Maven compiler plugin as we need to set it to Java 1.8 -->\n\n        \n<plugin>\n\n          \n<artifactId>\nmaven-compiler-plugin\n</artifactId>\n\n          \n<version>\n3.1\n</version>\n\n          \n<configuration>\n\n            \n<source>\n1.8\n</source>\n\n            \n<target>\n1.8\n</target>\n\n          \n</configuration>\n\n        \n</plugin>\n\n      \n</plugins>\n\n    \n</pluginManagement>\n\n    \n<plugins>\n\n      \n<plugin>\n\n        \n<groupId>\norg.apache.maven.plugins\n</groupId>\n\n        \n<artifactId>\nmaven-shade-plugin\n</artifactId>\n\n        \n<version>\n2.3\n</version>\n\n        \n<executions>\n\n          \n<execution>\n\n            \n<phase>\npackage\n</phase>\n\n            \n<goals>\n\n              \n<goal>\nshade\n</goal>\n\n            \n</goals>\n\n            \n<configuration>\n\n              \n<transformers>\n\n                \n<transformer\n \nimplementation=\n\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\"\n>\n\n                  \n<manifestEntries>\n\n                    \n<Main-Class>\nio.vertx.core.Launcher\n</Main-Class>\n\n                    \n<Main-Verticle>\ncom.example.Main\n</Main-Verticle>\n\n                  \n</manifestEntries>\n\n                \n</transformer>\n\n                \n<transformer\n \nimplementation=\n\"org.apache.maven.plugins.shade.resource.AppendingTransformer\"\n>\n\n                  \n<resource>\nMETA-INF/services/io.vertx.core.spi.VerticleFactory\n</resource>\n\n                \n</transformer>\n\n              \n</transformers>\n\n              \n<outputFile>\n${project.basedir}/target/${project.artifactId}-${project.version}-fat.jar\n</outputFile>\n\n            \n</configuration>\n\n          \n</execution>\n\n        \n</executions>\n\n      \n</plugin>\n\n    \n</plugins>\n\n  \n</build>\n\n\n</project>\n\n\n\n\n\nAnd the source code structure would be:\n\n\n.\n\u251c\u2500\u2500 pom.xml\n\u2514\u2500\u2500 src\n \u00a0\u00a0 \u2514\u2500\u2500 main\n \u00a0\u00a0     \u251c\u2500\u2500 java\n \u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 com\n \u00a0\u00a0     \u2502\u00a0\u00a0     \u2514\u2500\u2500 example\n \u00a0\u00a0     \u2502\u00a0\u00a0         \u2514\u2500\u2500 Main.java\n \u00a0\u00a0     \u2514\u2500\u2500 resources\n \u00a0\u00a0         \u2514\u2500\u2500 webroot\n \u00a0\u00a0             \u2514\u2500\u2500 index.html\n\n\n\n\nA minimal server\n\u00b6\n\n\nThe minimal \nServer\n would be the \nMain.java\n file and it should look like:\n\n\npackage\n \ncom.example\n;\n\n\n\nimport\n \nio.vertx.core.AbstractVerticle\n;\n\n\nimport\n \nio.vertx.ext.web.Router\n;\n\n\nimport\n \nio.vertx.ext.web.handler.StaticHandler\n;\n\n\n\nimport\n \nxyz.jetdrone.vertx.hot.reload.HotReload\n;\n\n\n\npublic\n \nclass\n \nMain\n \nextends\n \nAbstractVerticle\n \n{\n\n\n  \n@Override\n\n  \npublic\n \nvoid\n \nstart\n()\n \nthrows\n \nException\n \n{\n\n\n    \nfinal\n \nRouter\n \nrouter\n \n=\n \nRouter\n.\nrouter\n(\nvertx\n);\n\n    \n// development hot reload\n\n    \nrouter\n.\nget\n().\nhandler\n(\nHotReload\n.\ncreate\n());\n\n    \n// Serve the static resources\n\n    \nrouter\n.\nroute\n().\nhandler\n(\nStaticHandler\n.\ncreate\n());\n\n\n    \nvertx\n.\ncreateHttpServer\n().\nrequestHandler\n(\nrouter\n::\naccept\n).\nlisten\n(\n8080\n);\n\n  \n}\n\n\n}\n\n\n\n\n\nIt is very basic, it uses the hot deploy handler and serves static files.\n\n\nWhile the \nindex.html\n would be:\n\n\n<\nhtml\n>\n\n\n<\nhead\n>\n\n  \n<\ntitle\n>\nHot Reload\n</\ntitle\n>\n\n\n</\nhead\n>\n\n\n<\nbody\n>\n\n  \n<\ndiv\n \nid\n=\n\"main\"\n></\ndiv\n>\n\n  \n<\nscript\n \nsrc\n=\n\"bundle.js\"\n></\nscript\n>\n\n  \n<\nscript\n \nsrc\n=\n\"/hot-reload/script\"\n \ntype\n=\n\"application/javascript\"\n></\nscript\n>\n\n\n</\nbody\n>\n\n\n</\nhtml\n>\n\n\n\n\n\nWhat is this hot reload?\n\u00b6\n\n\nYou might have noticed these hot reload references. Hot reload is a handler that will reload your page every time your server restarts, it is a development time handler that you can ignore once you go into production but will save you many \nF5\n clicks.\n\n\nYou will see it in action later.\n\n\nA frontend application\n\u00b6\n\n\nLets look into the frontend aspect. Modern web development is complex, the most popular choices are between using:\n\n\n\n\nEcmaScript6\n\n\nTypeScript\n\n\n\n\nFor programming and\n\n\n\n\nAngular4\n\n\nReact.js\n\n\nVue.js\n\n\nAurelia\n\n\nBackbone\n\n\n\n\nas framework. But lets keep it simple, a simple hello world using \nwebpack\n since pretty much all these options rely on it as a base build and bundler.\n\n\nYour project will have some more files:\n\n\n.\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 client\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 index.js\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 main\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 java\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 com\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0     \u2514\u2500\u2500 example\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0         \u2514\u2500\u2500 Main.java\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 resources\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 webroot\n\u2502\u00a0\u00a0             \u2514\u2500\u2500 index.html\n\u2514\u2500\u2500 webpack.config.js\n\n\n\n\npackage.json\n\u00b6\n\n\nThe \npackage.json\n file is the couter part of \npom.xml\n for the frontend world, a minimal example would be:\n\n\n{\n\n  \n\"name\"\n:\n \n\"basic\"\n,\n\n  \n\"version\"\n:\n \n\"1.0.0\"\n,\n\n  \n\"description\"\n:\n \n\"\"\n,\n\n  \n\"private\"\n:\n \ntrue\n,\n\n\n  \n\"author\"\n:\n \n\"Paulo Lopes\"\n,\n\n  \n\"license\"\n:\n \n\"MIT\"\n,\n\n\n  \n\"dependencies\"\n:\n \n{\n\n  \n},\n\n\n  \n\"devDependencies\"\n:\n \n{\n\n    \n\"babel-core\"\n:\n \n\"^6.22.1\"\n,\n\n    \n\"babel-loader\"\n:\n \n\"^6.2.10\"\n,\n\n    \n\"webpack\"\n:\n \n\"^2.2.0\"\n,\n\n    \n\"webpack-vertx-plugin\"\n:\n \n\"0.0.2\"\n\n  \n}\n\n\n}\n\n\n\n\n\nRemember that I want to make a \nhello world\n example so there are no \ndependencies\n just \ndevDependencies\n so we can use webpack.\n\n\nConfigure webpack\n\u00b6\n\n\nWebpack is controlled by the file \nwebpack.config.js\n it is code as oposed to \npackage.json\n for this example it should be:\n\n\nvar\n \npath\n \n=\n \nrequire\n(\n'path'\n);\n\n\nconst\n \nVertxPlugin\n \n=\n \nrequire\n(\n'webpack-vertx-plugin'\n);\n\n\n\nmodule\n.\nexports\n \n=\n \n{\n\n  \nentry\n:\n \npath\n.\nresolve\n(\n__dirname\n,\n \n'src/client/index.js'\n),\n\n  \noutput\n:\n \n{\n\n    \nfilename\n:\n \n'bundle.js'\n,\n\n    \npath\n:\n \npath\n.\nresolve\n(\n__dirname\n,\n \n'src/main/resources/webroot'\n)\n\n  \n},\n\n  \nmodule\n:\n \n{\n\n    \nloaders\n:\n \n[\n\n      \n{\n \ntest\n:\n \n/\\.js$/\n,\n \nexclude\n:\n \n/node_modules/\n,\n \nloader\n:\n \n'babel-loader'\n \n}\n\n    \n]\n\n  \n},\n\n\n  \nplugins\n:\n \n[\n\n    \nnew\n \nVertxPlugin\n({\n\n      \nfatJar\n:\n \n'target/com.example-1.0.0-fat.jar'\n\n    \n})\n\n  \n]\n\n\n};\n\n\n\n\n\nWhat we're saying here is that our application starts from the \nsrc/client/index.js\n file and we will use \nbabel.js\n to transpile modern JavaScript to JavaScript browsers can handle.\n\n\nWe're using a special Vert.x plugin that does some nice tricks such as extracting \njs\n from java \njar\ns so they are available to babel. This gives you better code analysis and more optimized bundles.\n\n\nSo finally lets look at \nindex.js\n:\n\n\ndocument\n.\ngetElementById\n(\n\"main\"\n)\n\n  \n.\ninnerHTML\n \n=\n \n'Hello World!'\n;\n\n\n\n\n\nSimple!\n\n\nBuilding you application\n\u00b6\n\n\nWith the given setup \nwebpack\n will drive the build. The reason is that in order to build the backend one needs the frontend application under the \nsrc/main/resources\n so it can be packaged with the final runnable jar.\n\n\nWebpack does not know anything about java or maven so that is where the plugin gets in action. It will run \nmaven package\n once webpack sucessfuly builds.\n\n\nSo the flow will be:\n\n\n\n\nwebpack start\n\n\nbabel will transpile js if needed\n\n\nwebpack generates a \nbundle.js\n under \nsrc/main/resources/webroot\n\n\nVertxPlugin will run \nmvn package\n\n\n\n\nBut to you it would be just as running:\n\n\n$ webpack\nRunning: mvn...\nRunning: mvn...\nHash: ceaea9fa624993f698d5\nVersion: webpack 2.7.0\nTime: 6237ms\n        Asset     Size  Chunks             Chunk Names\n    bundle.js  2.73 kB       0  [emitted]  main\nbundle.js.map  2.88 kB       0  [emitted]  main\n   [0] ./src/client/index.js 59 bytes {0} [built]\n\n\n\n\nThis works great but you will find yourself restarting and reloading the server and browser all the time as you keep developing your application.\n\n\nWatching for changes\n\u00b6\n\n\nIn order to optimize the workflow, webpack can watch for changes and trigger a new build. However this does not apply to the java side of the project.\n\n\n\n\nNote\n\n\nYou can also watch changes with vert.x by running \njava -jar yourjar.jar --redeploy=\"src/**\" --on-redeploy=\"cmd to run\"\n.\n\n\n\n\nBut that would not be productive if you would need to do it manually so the plugin will identify when webpack is running in watch mode and do it for you.\n\n\nSo your run would be:\n\n\nwebpack --watch\n\nWebpack is watching the files\u2026\n\nRunning: mvn...\nRunning: java...\nHash: ceaea9fa624993f698d5\nVersion: webpack 2.7.0\nTime: 3641ms\n        Asset     Size  Chunks             Chunk Names\n    bundle.js  2.73 kB       0  [emitted]  main\nbundle.js.map  2.88 kB       0  [emitted]  main\n   [0] ./src/client/index.js 59 bytes {0} [built]\nSep 07, 2017 11:22:24 PM io.vertx.core.impl.launcher.commands.Watcher\nINFO: Watched paths: [/home/plopes/Projects/pmlopes/webpack-vertx-js/templates/minimal/src/main]\nSep 07, 2017 11:22:24 PM io.vertx.core.impl.launcher.commands.Watcher\nINFO: Starting the vert.x application in redeploy mode\nSep 07, 2017 11:22:24 PM io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer\nINFO: Succeeded in deploying verticle\n\n\n\n\nAnd you would see that the application would get recompiled if files are changed.\n\n\nHot reload\n\u00b6\n\n\nNow that you can watch for changes we can use the handlers stated initially and this would be like:",
            "title": "Web Development Workflow"
        },
        {
            "location": "/tips/web/workflow/#a-workflow-for-modern-web-development",
            "text": "Modern web development is more than just a HTTP server and generation of HTML on a request response workflow.  This would be the case in the old days of Servlet programming, nowadays we need to build complex single page applications with many resources and complex build steps.  With Vert.x we can define a workflow that is familiar both to backend developers and as well to frontend developers.",
            "title": "A Workflow for Modern Web Development"
        },
        {
            "location": "/tips/web/workflow/#a-backend-web-application",
            "text": "A typical backend application would be a server serving some content, for this one would use maven to build the application, your  pom.xml  would look like:  <?xml version=\"1.0\" encoding=\"UTF-8\"?>  <project   xmlns= \"http://maven.apache.org/POM/4.0.0\" \n          xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" \n          xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > \n\n   <modelVersion> 4.0.0 </modelVersion> \n   <packaging> jar </packaging> \n\n   <groupId> com.example </groupId> \n   <artifactId> com.example </artifactId> \n   <version> 1.0.0 </version> \n\n   <name> example </name> \n\n   <dependencies> \n     <dependency> \n       <groupId> io.vertx </groupId> \n       <artifactId> vertx-web </artifactId> \n       <version> 3.4.2 </version> \n     </dependency> \n     <dependency> \n       <groupId> xyz.jetdrone </groupId> \n       <artifactId> hot-reload </artifactId> \n       <version> 0.0.2 </version> \n     </dependency> \n   </dependencies> \n\n   <build> \n     <pluginManagement> \n       <plugins> \n         <!-- We specify the Maven compiler plugin as we need to set it to Java 1.8 --> \n         <plugin> \n           <artifactId> maven-compiler-plugin </artifactId> \n           <version> 3.1 </version> \n           <configuration> \n             <source> 1.8 </source> \n             <target> 1.8 </target> \n           </configuration> \n         </plugin> \n       </plugins> \n     </pluginManagement> \n     <plugins> \n       <plugin> \n         <groupId> org.apache.maven.plugins </groupId> \n         <artifactId> maven-shade-plugin </artifactId> \n         <version> 2.3 </version> \n         <executions> \n           <execution> \n             <phase> package </phase> \n             <goals> \n               <goal> shade </goal> \n             </goals> \n             <configuration> \n               <transformers> \n                 <transformer   implementation= \"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\" > \n                   <manifestEntries> \n                     <Main-Class> io.vertx.core.Launcher </Main-Class> \n                     <Main-Verticle> com.example.Main </Main-Verticle> \n                   </manifestEntries> \n                 </transformer> \n                 <transformer   implementation= \"org.apache.maven.plugins.shade.resource.AppendingTransformer\" > \n                   <resource> META-INF/services/io.vertx.core.spi.VerticleFactory </resource> \n                 </transformer> \n               </transformers> \n               <outputFile> ${project.basedir}/target/${project.artifactId}-${project.version}-fat.jar </outputFile> \n             </configuration> \n           </execution> \n         </executions> \n       </plugin> \n     </plugins> \n   </build>  </project>   And the source code structure would be:  .\n\u251c\u2500\u2500 pom.xml\n\u2514\u2500\u2500 src\n \u00a0\u00a0 \u2514\u2500\u2500 main\n \u00a0\u00a0     \u251c\u2500\u2500 java\n \u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 com\n \u00a0\u00a0     \u2502\u00a0\u00a0     \u2514\u2500\u2500 example\n \u00a0\u00a0     \u2502\u00a0\u00a0         \u2514\u2500\u2500 Main.java\n \u00a0\u00a0     \u2514\u2500\u2500 resources\n \u00a0\u00a0         \u2514\u2500\u2500 webroot\n \u00a0\u00a0             \u2514\u2500\u2500 index.html",
            "title": "A Backend web application"
        },
        {
            "location": "/tips/web/workflow/#a-minimal-server",
            "text": "The minimal  Server  would be the  Main.java  file and it should look like:  package   com.example ;  import   io.vertx.core.AbstractVerticle ;  import   io.vertx.ext.web.Router ;  import   io.vertx.ext.web.handler.StaticHandler ;  import   xyz.jetdrone.vertx.hot.reload.HotReload ;  public   class   Main   extends   AbstractVerticle   { \n\n   @Override \n   public   void   start ()   throws   Exception   { \n\n     final   Router   router   =   Router . router ( vertx ); \n     // development hot reload \n     router . get (). handler ( HotReload . create ()); \n     // Serve the static resources \n     router . route (). handler ( StaticHandler . create ()); \n\n     vertx . createHttpServer (). requestHandler ( router :: accept ). listen ( 8080 ); \n   }  }   It is very basic, it uses the hot deploy handler and serves static files.  While the  index.html  would be:  < html >  < head > \n   < title > Hot Reload </ title >  </ head >  < body > \n   < div   id = \"main\" ></ div > \n   < script   src = \"bundle.js\" ></ script > \n   < script   src = \"/hot-reload/script\"   type = \"application/javascript\" ></ script >  </ body >  </ html >",
            "title": "A minimal server"
        },
        {
            "location": "/tips/web/workflow/#what-is-this-hot-reload",
            "text": "You might have noticed these hot reload references. Hot reload is a handler that will reload your page every time your server restarts, it is a development time handler that you can ignore once you go into production but will save you many  F5  clicks.  You will see it in action later.",
            "title": "What is this hot reload?"
        },
        {
            "location": "/tips/web/workflow/#a-frontend-application",
            "text": "Lets look into the frontend aspect. Modern web development is complex, the most popular choices are between using:   EcmaScript6  TypeScript   For programming and   Angular4  React.js  Vue.js  Aurelia  Backbone   as framework. But lets keep it simple, a simple hello world using  webpack  since pretty much all these options rely on it as a base build and bundler.  Your project will have some more files:  .\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 client\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 index.js\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 main\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 java\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 com\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0     \u2514\u2500\u2500 example\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0         \u2514\u2500\u2500 Main.java\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 resources\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 webroot\n\u2502\u00a0\u00a0             \u2514\u2500\u2500 index.html\n\u2514\u2500\u2500 webpack.config.js",
            "title": "A frontend application"
        },
        {
            "location": "/tips/web/workflow/#packagejson",
            "text": "The  package.json  file is the couter part of  pom.xml  for the frontend world, a minimal example would be:  { \n   \"name\" :   \"basic\" , \n   \"version\" :   \"1.0.0\" , \n   \"description\" :   \"\" , \n   \"private\" :   true , \n\n   \"author\" :   \"Paulo Lopes\" , \n   \"license\" :   \"MIT\" , \n\n   \"dependencies\" :   { \n   }, \n\n   \"devDependencies\" :   { \n     \"babel-core\" :   \"^6.22.1\" , \n     \"babel-loader\" :   \"^6.2.10\" , \n     \"webpack\" :   \"^2.2.0\" , \n     \"webpack-vertx-plugin\" :   \"0.0.2\" \n   }  }   Remember that I want to make a  hello world  example so there are no  dependencies  just  devDependencies  so we can use webpack.",
            "title": "package.json"
        },
        {
            "location": "/tips/web/workflow/#configure-webpack",
            "text": "Webpack is controlled by the file  webpack.config.js  it is code as oposed to  package.json  for this example it should be:  var   path   =   require ( 'path' );  const   VertxPlugin   =   require ( 'webpack-vertx-plugin' );  module . exports   =   { \n   entry :   path . resolve ( __dirname ,   'src/client/index.js' ), \n   output :   { \n     filename :   'bundle.js' , \n     path :   path . resolve ( __dirname ,   'src/main/resources/webroot' ) \n   }, \n   module :   { \n     loaders :   [ \n       {   test :   /\\.js$/ ,   exclude :   /node_modules/ ,   loader :   'babel-loader'   } \n     ] \n   }, \n\n   plugins :   [ \n     new   VertxPlugin ({ \n       fatJar :   'target/com.example-1.0.0-fat.jar' \n     }) \n   ]  };   What we're saying here is that our application starts from the  src/client/index.js  file and we will use  babel.js  to transpile modern JavaScript to JavaScript browsers can handle.  We're using a special Vert.x plugin that does some nice tricks such as extracting  js  from java  jar s so they are available to babel. This gives you better code analysis and more optimized bundles.  So finally lets look at  index.js :  document . getElementById ( \"main\" ) \n   . innerHTML   =   'Hello World!' ;   Simple!",
            "title": "Configure webpack"
        },
        {
            "location": "/tips/web/workflow/#building-you-application",
            "text": "With the given setup  webpack  will drive the build. The reason is that in order to build the backend one needs the frontend application under the  src/main/resources  so it can be packaged with the final runnable jar.  Webpack does not know anything about java or maven so that is where the plugin gets in action. It will run  maven package  once webpack sucessfuly builds.  So the flow will be:   webpack start  babel will transpile js if needed  webpack generates a  bundle.js  under  src/main/resources/webroot  VertxPlugin will run  mvn package   But to you it would be just as running:  $ webpack\nRunning: mvn...\nRunning: mvn...\nHash: ceaea9fa624993f698d5\nVersion: webpack 2.7.0\nTime: 6237ms\n        Asset     Size  Chunks             Chunk Names\n    bundle.js  2.73 kB       0  [emitted]  main\nbundle.js.map  2.88 kB       0  [emitted]  main\n   [0] ./src/client/index.js 59 bytes {0} [built]  This works great but you will find yourself restarting and reloading the server and browser all the time as you keep developing your application.",
            "title": "Building you application"
        },
        {
            "location": "/tips/web/workflow/#watching-for-changes",
            "text": "In order to optimize the workflow, webpack can watch for changes and trigger a new build. However this does not apply to the java side of the project.   Note  You can also watch changes with vert.x by running  java -jar yourjar.jar --redeploy=\"src/**\" --on-redeploy=\"cmd to run\" .   But that would not be productive if you would need to do it manually so the plugin will identify when webpack is running in watch mode and do it for you.  So your run would be:  webpack --watch\n\nWebpack is watching the files\u2026\n\nRunning: mvn...\nRunning: java...\nHash: ceaea9fa624993f698d5\nVersion: webpack 2.7.0\nTime: 3641ms\n        Asset     Size  Chunks             Chunk Names\n    bundle.js  2.73 kB       0  [emitted]  main\nbundle.js.map  2.88 kB       0  [emitted]  main\n   [0] ./src/client/index.js 59 bytes {0} [built]\nSep 07, 2017 11:22:24 PM io.vertx.core.impl.launcher.commands.Watcher\nINFO: Watched paths: [/home/plopes/Projects/pmlopes/webpack-vertx-js/templates/minimal/src/main]\nSep 07, 2017 11:22:24 PM io.vertx.core.impl.launcher.commands.Watcher\nINFO: Starting the vert.x application in redeploy mode\nSep 07, 2017 11:22:24 PM io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer\nINFO: Succeeded in deploying verticle  And you would see that the application would get recompiled if files are changed.",
            "title": "Watching for changes"
        },
        {
            "location": "/tips/web/workflow/#hot-reload",
            "text": "Now that you can watch for changes we can use the handlers stated initially and this would be like:",
            "title": "Hot reload"
        },
        {
            "location": "/contributing/",
            "text": "Contributing\n\u00b6\n\n\nInterested in contributing to the Vert.x Tutorials? Want to report a bug? Before\nyou do, please read the following guidelines.\n\n\nSubmission context\n\u00b6\n\n\nGot a question or problem?\n\u00b6\n\n\nFor quick questions there's no need to open an issue as you can reach us on\n\ngoogle groups\n.\n\n\nFound a bug?\n\u00b6\n\n\nIf you found a bug in the source code, you can help us by submitting an issue\nto the \nissue tracker\n in our GitHub repository. Even better, you can submit\na Pull Request with a fix. However, before doing so, please read the\n\nsubmission guidelines\n.\n\n\nMissing a feature?\n\u00b6\n\n\nYou can request a new feature by submitting an issue to our GitHub Repository.\nIf you would like to implement a new feature, please submit an issue with a\nproposal for your work first, to be sure that it is of use for everyone, as\nthe Material theme is highly opinionated. Please consider what kind of change\nit is:\n\n\n\n\n\n\nFor a \nmajor feature\n, first open an issue and outline your proposal so\n  that it can be discussed. This will also allow us to better coordinate our\n  efforts, prevent duplication of work, and help you to craft the change so\n  that it is successfully accepted into the project.\n\n\n\n\n\n\nSmall features and bugs\n can be crafted and directly submitted as a Pull\n  Request. However, there is no guarantee that your feature will make it into\n  the master, as it's always a matter of opinion whether if benefits the\n  overall functionality of the theme.\n\n\n\n\n\n\nSubmission guidelines\n\u00b6\n\n\nSubmitting an issue\n\u00b6\n\n\nBefore you submit an issue, please search the issue tracker, maybe an issue for\nyour problem already exists and the discussion might inform you of workarounds\nreadily available.\n\n\nWe want to fix all the issues as soon as possible, but before fixing a bug we\nneed to reproduce and confirm it. In order to reproduce bugs we will\nsystematically ask you to provide a minimal reproduction scenario using the\ncustom issue template. Please stick to the issue template.\n\n\nUnfortunately we are not able to investigate / fix bugs without a minimal\nreproduction scenario, so if we don't hear back from you we may close the issue.\n\n\nSubmitting a Pull Request (PR)\n\u00b6\n\n\nSearch GitHub for an open or closed PR that relates to your submission. You\ndon't want to duplicate effort. If you do not find a related issue or PR,\ngo ahead.\n\n\n\n\n\n\nDevelopment\n: Fork the project, make your changes in a\n  separate git branch and add descriptive messages to\n  your commits.\n\n\n\n\n\n\nBuild\n: Before submitting a pull requests, build the theme. This is a\n  mandatory requirement for your PR to get accepted, as the theme should at\n  all times be installable through GitHub.\n\n\n\n\n\n\nPull Request\n: After building the theme, commit the compiled output, push\n  your branch to GitHub and send a PR to \nvertx-tutorials:master\n. If we\n  suggest changes, make the required updates, rebase your branch and push the\n  changes to your GitHub repository, which will automatically update your PR.\n\n\n\n\n\n\nAfter your PR is merged, you can safely delete your branch and pull the changes\nfrom the main (upstream) repository.",
            "title": "Contributing"
        },
        {
            "location": "/contributing/#contributing",
            "text": "Interested in contributing to the Vert.x Tutorials? Want to report a bug? Before\nyou do, please read the following guidelines.",
            "title": "Contributing"
        },
        {
            "location": "/contributing/#submission-context",
            "text": "",
            "title": "Submission context"
        },
        {
            "location": "/contributing/#got-a-question-or-problem",
            "text": "For quick questions there's no need to open an issue as you can reach us on google groups .",
            "title": "Got a question or problem?"
        },
        {
            "location": "/contributing/#found-a-bug",
            "text": "If you found a bug in the source code, you can help us by submitting an issue\nto the  issue tracker  in our GitHub repository. Even better, you can submit\na Pull Request with a fix. However, before doing so, please read the submission guidelines .",
            "title": "Found a bug?"
        },
        {
            "location": "/contributing/#missing-a-feature",
            "text": "You can request a new feature by submitting an issue to our GitHub Repository.\nIf you would like to implement a new feature, please submit an issue with a\nproposal for your work first, to be sure that it is of use for everyone, as\nthe Material theme is highly opinionated. Please consider what kind of change\nit is:    For a  major feature , first open an issue and outline your proposal so\n  that it can be discussed. This will also allow us to better coordinate our\n  efforts, prevent duplication of work, and help you to craft the change so\n  that it is successfully accepted into the project.    Small features and bugs  can be crafted and directly submitted as a Pull\n  Request. However, there is no guarantee that your feature will make it into\n  the master, as it's always a matter of opinion whether if benefits the\n  overall functionality of the theme.",
            "title": "Missing a feature?"
        },
        {
            "location": "/contributing/#submission-guidelines",
            "text": "",
            "title": "Submission guidelines"
        },
        {
            "location": "/contributing/#submitting-an-issue",
            "text": "Before you submit an issue, please search the issue tracker, maybe an issue for\nyour problem already exists and the discussion might inform you of workarounds\nreadily available.  We want to fix all the issues as soon as possible, but before fixing a bug we\nneed to reproduce and confirm it. In order to reproduce bugs we will\nsystematically ask you to provide a minimal reproduction scenario using the\ncustom issue template. Please stick to the issue template.  Unfortunately we are not able to investigate / fix bugs without a minimal\nreproduction scenario, so if we don't hear back from you we may close the issue.",
            "title": "Submitting an issue"
        },
        {
            "location": "/contributing/#submitting-a-pull-request-pr",
            "text": "Search GitHub for an open or closed PR that relates to your submission. You\ndon't want to duplicate effort. If you do not find a related issue or PR,\ngo ahead.    Development : Fork the project, make your changes in a\n  separate git branch and add descriptive messages to\n  your commits.    Build : Before submitting a pull requests, build the theme. This is a\n  mandatory requirement for your PR to get accepted, as the theme should at\n  all times be installable through GitHub.    Pull Request : After building the theme, commit the compiled output, push\n  your branch to GitHub and send a PR to  vertx-tutorials:master . If we\n  suggest changes, make the required updates, rebase your branch and push the\n  changes to your GitHub repository, which will automatically update your PR.    After your PR is merged, you can safely delete your branch and pull the changes\nfrom the main (upstream) repository.",
            "title": "Submitting a Pull Request (PR)"
        },
        {
            "location": "/license/",
            "text": "License\n\u00b6\n\n\nMIT License\n\n\nCopyright \u00a9 2017 Paulo Lopes\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.",
            "title": "License"
        },
        {
            "location": "/license/#license",
            "text": "MIT License  Copyright \u00a9 2017 Paulo Lopes  Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.",
            "title": "License"
        }
    ]
}