{
    "docs": [
        {
            "location": "/",
            "text": "Tutorials \nfor Eclipse Vert.x\n\u00b6\n\n\nSimple tutorials to get you started\n\u00b6\n\n\nEclipse Vert.x is a tool-kit for building reactive applications on the JVM.\n\n\nEnjoy being a developer again.\n\n\nUnlike restrictive traditional application containers, Vert.x gives you incredible power and agility to create compelling, scalable, 21\nst\n century applications the way you want to, with a minimum of fuss, in the language you want.",
            "title": "Welcome"
        },
        {
            "location": "/#tutorials-for-eclipse-vertx",
            "text": "",
            "title": "Tutorials for Eclipse Vert.x"
        },
        {
            "location": "/#simple-tutorials-to-get-you-started",
            "text": "Eclipse Vert.x is a tool-kit for building reactive applications on the JVM.  Enjoy being a developer again.  Unlike restrictive traditional application containers, Vert.x gives you incredible power and agility to create compelling, scalable, 21 st  century applications the way you want to, with a minimum of fuss, in the language you want.",
            "title": "Simple tutorials to get you started"
        },
        {
            "location": "/oauth2/github/",
            "text": "Basics of Authentication\n\u00b6\n\n\nIn this section, we're going to focus on the basics of authentication. Specifically, we're going to create a Java server (using \nvert.x\n) that implements the \nweb flow\n of an application in several different ways.\n\n\n\n\nNote\n\n\nYou can download the complete source code for this project from the \nvertx-examples\n repo.\n\n\n\n\nRegistering your app\n\u00b6\n\n\nFirst, you'll need to \nregister your application\n. Every registered OAuth application is assigned a unique Client ID and Client Secret. The Client Secret should not be shared! That includes checking the string into your repository.\n\n\nYou can fill out every piece of information however you like, except the \nAuthorization callback URL\n. This is easily the most important piece to setting up your application. It's the callback URL that GitHub returns the user to after successful authentication.\n\n\nSince we're running a regular Sinatra server, the location of the local instance is set to \nhttp://localhost:8080\n. Let's fill in the callback URL as \nhttp://localhost:8080/callback\n.\n\n\nAccepting user authorization\n\u00b6\n\n\nNow, let's start filling out our simple server. Create a class called \nio.acme.Server\n and paste this into it:\n\n\npackage\n \nio.acme\n;\n\n\n\nimport\n \nio.vertx.core.AbstractVerticle\n;\n\n\nimport\n \nio.vertx.core.json.JsonObject\n;\n\n\nimport\n \nio.vertx.ext.auth.oauth2.*\n;\n\n\nimport\n \nio.vertx.ext.auth.oauth2.providers.GithubAuth\n;\n\n\nimport\n \nio.vertx.ext.web.Router\n;\n\n\nimport\n \nio.vertx.ext.web.handler.*\n;\n\n\nimport\n \nio.vertx.ext.web.templ.HandlebarsTemplateEngine\n;\n\n\n\npublic\n \nclass\n \nServer\n \nextends\n \nAbstractVerticle\n \n{\n\n\n  \nprivate\n \nstatic\n \nfinal\n \nString\n \nCLIENT_ID\n \n=\n\n    \nSystem\n.\ngetEnv\n(\n\"GITHUB_CLIENT_ID\"\n);\n\n  \nprivate\n \nstatic\n \nfinal\n \nString\n \nCLIENT_SECRET\n \n=\n\n    \nSystem\n.\ngetEnv\n(\n\"GITHUB_CLIENT_SECRET\"\n);\n\n\n  \n// In order to use a template we first need to\n\n  \n// create an engine\n\n  \nprivate\n \nfinal\n \nHandlebarsTemplateEngine\n \nengine\n \n=\n\n    \nHandlebarsTemplateEngine\n.\ncreate\n();\n\n\n  \n@Override\n\n  \npublic\n \nvoid\n \nstart\n()\n \nthrows\n \nException\n \n{\n\n    \n// To simplify the development of the web components\n\n    \n// we use a Router to route all HTTP requests\n\n    \n// to organize our code in a reusable way.\n\n    \nfinal\n \nRouter\n \nrouter\n \n=\n \nRouter\n.\nrouter\n(\nvertx\n);\n\n    \n// we now protect the resource under the path \"/protected\"\n\n    \nrouter\n.\nroute\n(\n\"/protected\"\n).\nhandler\n(\n\n      \nOAuth2AuthHandler\n.\ncreate\n(\nauthProvider\n)\n\n        \n// for this resource we require that users have\n\n        \n// the authority to retrieve the user emails\n\n        \n.\naddAuthority\n(\n\"user:email\"\n)\n\n    \n);\n\n    \n// Entry point to the application, this will render\n\n    \n// a custom template.\n\n    \nrouter\n.\nget\n(\n\"/\"\n).\nhandler\n(\nctx\n \n->\n \n{\n\n      \n// we pass the client id to the template\n\n      \nctx\n.\nput\n(\n\"client_id\"\n,\n \nCLIENT_ID\n);\n\n      \n// and now delegate to the engine to render it.\n\n      \nengine\n.\nrender\n(\nctx\n,\n \n\"views\"\n,\n \n\"/index.hbs\"\n,\n \nres\n \n->\n \n{\n\n        \nif\n \n(\nres\n.\nsucceeded\n())\n \n{\n\n          \nctx\n.\nresponse\n()\n\n            \n.\nputHeader\n(\n\"Content-Type\"\n,\n \n\"text/html\"\n)\n\n            \n.\nend\n(\nres\n.\nresult\n());\n\n        \n}\n \nelse\n \n{\n\n          \nctx\n.\nfail\n(\nres\n.\ncause\n());\n\n        \n}\n\n      \n});\n\n    \n});\n\n    \n// The protected resource\n\n    \nrouter\n.\nget\n(\n\"/protected\"\n).\nhandler\n(\nctx\n \n->\n \n{\n\n      \nctx\n.\nresponse\n()\n\n        \n.\nend\n(\n\"Hello protected!\"\n);\n\n    \n});\n\n\n    \nvertx\n.\ncreateHttpServer\n()\n\n      \n.\nrequestHandler\n(\nrouter\n::\naccept\n)\n\n      \n.\nlisten\n(\n8080\n);\n\n  \n}\n\n\n}\n\n\n\n\n\nYour client ID and client secret keys come from \nyour application's configuration page\n. You should \nnever, ever\n store these values in GitHub--or any other public place, for that matter. We recommend storing them as \nenvironment variables\n -- which is exactly what we've done here.\n\n\nNotice that the protected resource uses the scope \nuser:email\n to define the scopes requested by the application. For our application, we're requesting \nuser:email\n scope for reading private email addresses.\n\n\nNext, in the \nproject resources\n create the template \nviews/index.hbs\n and paste this content:\n\n\n<html>\n  <body>\n    <p>\n      Well, hello there!\n    </p>\n    <p>\n      We're going to the protected resource, if there is no\n      user in the session we will talk to the GitHub API. Ready?\n      <a href=\"/protected\">Click here</a> to begin!</a>\n    </p>\n    <p>\n      <b>If that link doesn't work</b>, remember to provide\n      your own <a href=\"https://github.com/settings/applications/new\">\n      Client ID</a>!\n    </p>\n  </body>\n</html>\n\n\n\n\n(If you're unfamiliar with how \nHandlebars\n works, we recommend reading the \nHandlebars\n guide.)\n\n\nNavigate your browser to \nhttp://localhost:8080\n. After clicking on the link, you should be taken to GitHub, and presented with a dialog that looks something like this:\n\n\n\n\nIf you trust yourself, click \nAuthorize App\n. Wuh-oh! Vert.x spits out a 500 error (with the message \ncallback route is not configured\n). What gives?!\n\n\nWell, remember when we specified a Callback URL to be \ncallback\n? We didn't provide a route for it, so GitHub doesn't know where to drop the user after they authorize the app. Let's fix that now!\n\n\nProviding a callback\n\u00b6\n\n\nIn the \nServer\n class you don't need to know the internal of the OAuth2 protocol, the \nOAuth2AuthHandler\n can do it for if you configure the protection as:\n\n\nrouter\n.\nroute\n(\n\"/protected\"\n).\nhandler\n(\n\n  \nOAuth2AuthHandler\n.\ncreate\n(\nauthProvider\n)\n\n    \n// we now configure the oauth2 handler,\n\n    \n// it will setup the callback handler\n\n    \n// as expected by your oauth2 provider.\n\n    \n.\nsetupCallback\n(\nrouter\n.\nroute\n(\n\"/callback\"\n))\n\n    \n// for this resource we require that\n\n    \n// users have the authority to retrieve\n\n    \n// the user emails\n\n    \n.\naddAuthority\n(\n\"user:email\"\n));\n\n\n\n\n\nAfter a successful app authentication, GitHub provides a temporary \ncode\n value. This code is then \nPOST\ned back to GitHub in exchange for an \naccess_token\n which is in turn translated to a \nUser\n instance in your vert.x application. All this is taken care for you by the handler.\n\n\nChecking granted scopes\n\u00b6\n\n\nBefore the \nUser\n object is handled to you, if your handler was configured with \nauthorities\n they will be first checked. If they are not present then they the whole process is aborted with an \nAuthorization\n error.\n\n\nHowever you might want to assert for other granted authorities, in this case you would:\n\n\nctx\n.\nuser\n()\n\n  \n.\nisAuthorised\n(\n\"some:authority\"\n,\n \nres\n \n->\n \n{\n\n    \nif\n \n(\nres\n.\nfailed\n())\n \n{\n\n      \n// some error handling here...\n\n    \n}\n \nelse\n \n{\n\n      \nif\n \n(\nres\n.\nresult\n())\n \n{\n\n        \n// is authorized!\n\n      \n}\n \nelse\n \n{\n\n        \n// is not authorized!\n\n      \n}\n\n    \n}\n\n  \n});\n\n\n\n\n\nMaking authenticated request\n\u00b6\n\n\nAt last, with this access token, you'll be able to make authenticated requests as the logged in user:\n\n\n// we cast the user to a specialized implementation\n\n\nAccessToken\n \nuser\n \n=\n \n(\nAccessToken\n)\n \nctx\n.\nuser\n();\n\n\n// retrieve the user profile, this is a common feature\n\n\n// but not from the official OAuth2 spec\n\n\nuser\n.\nuserInfo\n(\nres\n \n->\n \n{\n\n  \nif\n \n(\nres\n.\nfailed\n())\n \n{\n\n    \n// request didn't succeed because the token was revoked so we\n\n    \n// invalidate the token stored in the session and render the\n\n    \n// index page so that the user can start the OAuth flow again\n\n    \nctx\n.\nsession\n().\ndestroy\n();\n\n    \nctx\n.\nfail\n(\nres\n.\ncause\n());\n\n    \nreturn\n;\n\n  \n}\n\n\n  \n// the request succeeded, so we use the API to fetch the user's emails\n\n  \nfinal\n \nJsonObject\n \nuserInfo\n \n=\n \nres\n.\nresult\n();\n\n\n  \n// fetch the user emails from the github API\n\n\n  \n// the fetch method will retrieve any resource and ensure the right\n\n  \n// secure headers are passed.\n\n  \nuser\n.\nfetch\n(\n\"https://api.github.com/user/emails\"\n,\n \nres2\n \n->\n \n{\n\n    \nif\n \n(\nres2\n.\nfailed\n())\n \n{\n\n      \nctx\n.\nsession\n().\ndestroy\n();\n\n      \nctx\n.\nfail\n(\nres\n.\ncause\n());\n\n      \nreturn\n;\n\n    \n}\n\n\n    \nuserInfo\n.\nput\n(\n\"private_emails\"\n,\n \nres2\n.\nresult\n().\njsonArray\n());\n\n    \n// we pass the client info to the template\n\n    \nctx\n.\nput\n(\n\"userInfo\"\n,\n \nuserInfo\n);\n\n    \n// and now delegate to the engine to render it.\n\n    \nengine\n.\nrender\n(\nctx\n,\n \n\"views\"\n,\n \n\"/advanced.hbs\"\n,\n \nres3\n \n->\n \n{\n\n      \nif\n \n(\nres3\n.\nsucceeded\n())\n \n{\n\n        \nctx\n.\nresponse\n()\n\n          \n.\nputHeader\n(\n\"Content-Type\"\n,\n \n\"text/html\"\n)\n\n          \n.\nend\n(\nres3\n.\nresult\n());\n\n      \n}\n \nelse\n \n{\n\n        \nctx\n.\nfail\n(\nres3\n.\ncause\n());\n\n      \n}\n\n    \n});\n\n  \n});\n\n\n});\n\n\n\n\n\nWe can do whatever we want with our results. In this case, we'll just dump them straight into \nadvanced.hbs\n:\n\n\n<html>\n<body>\n<p>Well, well, well, {{userInfo.login}}!</p>\n<p>\n  {{#if userInfo.email}} It looks like your public email\n  address is {{userInfo.email}}.\n  {{else}} It looks like you don't have a public email.\n  That's cool.\n  {{/if}}\n</p>\n<p>\n  {{#if userInfo.private_emails}}\n  With your permission, we were also able to dig up your\n  private email addresses:\n  {{#each userInfo.private_emails}}\n    {{email}}{{#unless @last}},{{/unless}}\n  {{/each}}\n  {{else}}\n  Also, you're a bit secretive about your private email\n  addresses.\n  {{/if}}\n</p>\n</body>\n</html>\n\n\n\n\nImplementing \"persistent\" authentication\n\u00b6\n\n\nIt'd be a pretty bad model if we required users to log into the app every single time they needed to access the web page. For example, try navigating directly to \nhttp://localhost:8080/protected\n. You'll get an authentication request over and over.\n\n\nWhat if we could circumvent the entire \"click here\" process, and just remember that, as long as the user's logged into GitHub, they should be able to access this application? Hold on to your hat, because that's \nexactly what we're going to do\n.\n\n\nOur little server above is rather simple. In order to wedge in some intelligent authentication, we're going to switch over to using sessions for storing tokens. This will make authentication transparent to the user.\n\n\nThis can be achived with the stock handlers so our server file would be:\n\n\npackage\n \nio.acme\n;\n\n\n\nimport\n \nio.vertx.core.AbstractVerticle\n;\n\n\nimport\n \nio.vertx.core.json.JsonObject\n;\n\n\nimport\n \nio.vertx.ext.auth.oauth2.AccessToken\n;\n\n\nimport\n \nio.vertx.ext.auth.oauth2.OAuth2Auth\n;\n\n\nimport\n \nio.vertx.ext.auth.oauth2.providers.GithubAuth\n;\n\n\nimport\n \nio.vertx.ext.web.Router\n;\n\n\nimport\n \nio.vertx.ext.web.handler.*\n;\n\n\nimport\n \nio.vertx.ext.web.sstore.LocalSessionStore\n;\n\n\nimport\n \nio.vertx.ext.web.templ.HandlebarsTemplateEngine\n;\n\n\n\npublic\n \nclass\n \nServer\n \nextends\n \nAbstractVerticle\n \n{\n\n\n  \nprivate\n \nstatic\n \nfinal\n \nString\n \nCLIENT_ID\n \n=\n\n    \nSystem\n.\ngetEnv\n(\n\"GITHUB_CLIENT_ID\"\n);\n\n  \nprivate\n \nstatic\n \nfinal\n \nString\n \nCLIENT_SECRET\n \n=\n\n    \nSystem\n.\ngetEnv\n(\n\"GITHUB_CLIENT_SECRET\"\n);\n\n\n  \n// In order to use a template we first need to\n\n  \n// create an engine\n\n  \nprivate\n \nfinal\n \nHandlebarsTemplateEngine\n \nengine\n \n=\n\n    \nHandlebarsTemplateEngine\n.\ncreate\n();\n\n\n  \n@Override\n\n  \npublic\n \nvoid\n \nstart\n()\n \nthrows\n \nException\n \n{\n\n    \n// To simplify the development of the web components\n\n    \n// we use a Router to route all HTTP requests\n\n    \n// to organize our code in a reusable way.\n\n    \nfinal\n \nRouter\n \nrouter\n \n=\n \nRouter\n.\nrouter\n(\nvertx\n);\n\n    \n// We need cookies and sessions\n\n    \nrouter\n.\nroute\n()\n\n      \n.\nhandler\n(\nCookieHandler\n.\ncreate\n());\n\n    \nrouter\n.\nroute\n()\n\n      \n.\nhandler\n(\nSessionHandler\n.\ncreate\n(\nLocalSessionStore\n.\ncreate\n(\nvertx\n)));\n\n    \n// Simple auth service which uses a GitHub to\n\n    \n// authenticate the user\n\n    \nOAuth2Auth\n \nauthProvider\n \n=\n\n      \nGithubAuth\n.\ncreate\n(\nvertx\n,\n \nCLIENT_ID\n,\n \nCLIENT_SECRET\n);\n\n    \n// We need a user session handler too to make sure\n\n    \n// the user is stored in the session between requests\n\n    \nrouter\n.\nroute\n()\n\n      \n.\nhandler\n(\nUserSessionHandler\n.\ncreate\n(\nauthProvider\n));\n\n    \n// we now protect the resource under the path \"/protected\"\n\n    \nrouter\n.\nroute\n(\n\"/protected\"\n).\nhandler\n(\n\n      \nOAuth2AuthHandler\n.\ncreate\n(\nauthProvider\n)\n\n        \n// we now configure the oauth2 handler, it will\n\n        \n// setup the callback handler\n\n        \n// as expected by your oauth2 provider.\n\n        \n.\nsetupCallback\n(\nrouter\n.\nroute\n(\n\"/callback\"\n))\n\n        \n// for this resource we require that users have\n\n        \n// the authority to retrieve the user emails\n\n        \n.\naddAuthority\n(\n\"user:email\"\n)\n\n    \n);\n\n    \n// Entry point to the application, this will render\n\n    \n// a custom template.\n\n    \nrouter\n.\nget\n(\n\"/\"\n).\nhandler\n(\nctx\n \n->\n \n{\n\n      \n// we pass the client id to the template\n\n      \nctx\n.\nput\n(\n\"client_id\"\n,\n \nCLIENT_ID\n);\n\n      \n// and now delegate to the engine to render it.\n\n      \nengine\n.\nrender\n(\nctx\n,\n \n\"views\"\n,\n \n\"/index.hbs\"\n,\n \nres\n \n->\n \n{\n\n        \nif\n \n(\nres\n.\nsucceeded\n())\n \n{\n\n          \nctx\n.\nresponse\n()\n\n            \n.\nputHeader\n(\n\"Content-Type\"\n,\n \n\"text/html\"\n)\n\n            \n.\nend\n(\nres\n.\nresult\n());\n\n        \n}\n \nelse\n \n{\n\n          \nctx\n.\nfail\n(\nres\n.\ncause\n());\n\n        \n}\n\n      \n});\n\n    \n});\n\n    \n// The protected resource\n\n    \nrouter\n.\nget\n(\n\"/protected\"\n).\nhandler\n(\nctx\n \n->\n \n{\n\n      \nAccessToken\n \nuser\n \n=\n \n(\nAccessToken\n)\n \nctx\n.\nuser\n();\n\n      \n// retrieve the user profile, this is a common\n\n      \n// feature but not from the official OAuth2 spec\n\n      \nuser\n.\nuserInfo\n(\nres\n \n->\n \n{\n\n        \nif\n \n(\nres\n.\nfailed\n())\n \n{\n\n          \n// request didn't succeed because the token\n\n          \n// was revoked so we invalidate the token stored\n\n          \n// in the session and render an error page\n\n          \n// so that the user can start the OAuth flow again\n\n          \nctx\n.\nsession\n().\ndestroy\n();\n\n          \nctx\n.\nfail\n(\nres\n.\ncause\n());\n\n        \n}\n \nelse\n \n{\n\n          \n// the request succeeded, so we use the API to\n\n          \n// fetch the user's emails\n\n          \nfinal\n \nJsonObject\n \nuserInfo\n \n=\n \nres\n.\nresult\n();\n\n\n          \n// fetch the user emails from the github API\n\n\n          \n// the fetch method will retrieve any resource and\n\n          \n// ensure the right secure headers are passed.\n\n          \nuser\n.\nfetch\n(\n\"https://api.github.com/user/emails\"\n,\n \nres2\n \n->\n \n{\n\n            \nif\n \n(\nres2\n.\nfailed\n())\n \n{\n\n              \n// request didn't succeed because the token\n\n              \n// was revoked so we invalidate the token stored\n\n              \n// in the session and render an error page\n\n              \n// so that the user can start the OAuth flow again\n\n              \nctx\n.\nsession\n().\ndestroy\n();\n\n              \nctx\n.\nfail\n(\nres2\n.\ncause\n());\n\n            \n}\n \nelse\n \n{\n\n              \nuserInfo\n.\nput\n(\n\"private_emails\"\n,\n \nres2\n.\nresult\n().\njsonArray\n());\n\n              \n// we pass the client info to the template\n\n              \nctx\n.\nput\n(\n\"userInfo\"\n,\n \nuserInfo\n);\n\n              \n// and now delegate to the engine to render it.\n\n              \nengine\n.\nrender\n(\nctx\n,\n \n\"views\"\n,\n \n\"/advanced.hbs\"\n,\n \nres3\n \n->\n \n{\n\n                \nif\n \n(\nres3\n.\nsucceeded\n())\n \n{\n\n                  \nctx\n.\nresponse\n()\n\n                    \n.\nputHeader\n(\n\"Content-Type\"\n,\n \n\"text/html\"\n)\n\n                    \n.\nend\n(\nres3\n.\nresult\n());\n\n                \n}\n \nelse\n \n{\n\n                  \nctx\n.\nfail\n(\nres3\n.\ncause\n());\n\n                \n}\n\n              \n});\n\n            \n}\n\n          \n});\n\n        \n}\n\n      \n});\n\n    \n});\n\n\n    \nvertx\n.\ncreateHttpServer\n().\nrequestHandler\n(\nrouter\n::\naccept\n).\nlisten\n(\n8080\n);\n\n  \n}\n\n\n}\n\n\n\n\n\nI hope you now can use OAuth2 on your next project!",
            "title": "Oauth2"
        },
        {
            "location": "/oauth2/github/#basics-of-authentication",
            "text": "In this section, we're going to focus on the basics of authentication. Specifically, we're going to create a Java server (using  vert.x ) that implements the  web flow  of an application in several different ways.   Note  You can download the complete source code for this project from the  vertx-examples  repo.",
            "title": "Basics of Authentication"
        },
        {
            "location": "/oauth2/github/#registering-your-app",
            "text": "First, you'll need to  register your application . Every registered OAuth application is assigned a unique Client ID and Client Secret. The Client Secret should not be shared! That includes checking the string into your repository.  You can fill out every piece of information however you like, except the  Authorization callback URL . This is easily the most important piece to setting up your application. It's the callback URL that GitHub returns the user to after successful authentication.  Since we're running a regular Sinatra server, the location of the local instance is set to  http://localhost:8080 . Let's fill in the callback URL as  http://localhost:8080/callback .",
            "title": "Registering your app"
        },
        {
            "location": "/oauth2/github/#accepting-user-authorization",
            "text": "Now, let's start filling out our simple server. Create a class called  io.acme.Server  and paste this into it:  package   io.acme ;  import   io.vertx.core.AbstractVerticle ;  import   io.vertx.core.json.JsonObject ;  import   io.vertx.ext.auth.oauth2.* ;  import   io.vertx.ext.auth.oauth2.providers.GithubAuth ;  import   io.vertx.ext.web.Router ;  import   io.vertx.ext.web.handler.* ;  import   io.vertx.ext.web.templ.HandlebarsTemplateEngine ;  public   class   Server   extends   AbstractVerticle   { \n\n   private   static   final   String   CLIENT_ID   = \n     System . getEnv ( \"GITHUB_CLIENT_ID\" ); \n   private   static   final   String   CLIENT_SECRET   = \n     System . getEnv ( \"GITHUB_CLIENT_SECRET\" ); \n\n   // In order to use a template we first need to \n   // create an engine \n   private   final   HandlebarsTemplateEngine   engine   = \n     HandlebarsTemplateEngine . create (); \n\n   @Override \n   public   void   start ()   throws   Exception   { \n     // To simplify the development of the web components \n     // we use a Router to route all HTTP requests \n     // to organize our code in a reusable way. \n     final   Router   router   =   Router . router ( vertx ); \n     // we now protect the resource under the path \"/protected\" \n     router . route ( \"/protected\" ). handler ( \n       OAuth2AuthHandler . create ( authProvider ) \n         // for this resource we require that users have \n         // the authority to retrieve the user emails \n         . addAuthority ( \"user:email\" ) \n     ); \n     // Entry point to the application, this will render \n     // a custom template. \n     router . get ( \"/\" ). handler ( ctx   ->   { \n       // we pass the client id to the template \n       ctx . put ( \"client_id\" ,   CLIENT_ID ); \n       // and now delegate to the engine to render it. \n       engine . render ( ctx ,   \"views\" ,   \"/index.hbs\" ,   res   ->   { \n         if   ( res . succeeded ())   { \n           ctx . response () \n             . putHeader ( \"Content-Type\" ,   \"text/html\" ) \n             . end ( res . result ()); \n         }   else   { \n           ctx . fail ( res . cause ()); \n         } \n       }); \n     }); \n     // The protected resource \n     router . get ( \"/protected\" ). handler ( ctx   ->   { \n       ctx . response () \n         . end ( \"Hello protected!\" ); \n     }); \n\n     vertx . createHttpServer () \n       . requestHandler ( router :: accept ) \n       . listen ( 8080 ); \n   }  }   Your client ID and client secret keys come from  your application's configuration page . You should  never, ever  store these values in GitHub--or any other public place, for that matter. We recommend storing them as  environment variables  -- which is exactly what we've done here.  Notice that the protected resource uses the scope  user:email  to define the scopes requested by the application. For our application, we're requesting  user:email  scope for reading private email addresses.  Next, in the  project resources  create the template  views/index.hbs  and paste this content:  <html>\n  <body>\n    <p>\n      Well, hello there!\n    </p>\n    <p>\n      We're going to the protected resource, if there is no\n      user in the session we will talk to the GitHub API. Ready?\n      <a href=\"/protected\">Click here</a> to begin!</a>\n    </p>\n    <p>\n      <b>If that link doesn't work</b>, remember to provide\n      your own <a href=\"https://github.com/settings/applications/new\">\n      Client ID</a>!\n    </p>\n  </body>\n</html>  (If you're unfamiliar with how  Handlebars  works, we recommend reading the  Handlebars  guide.)  Navigate your browser to  http://localhost:8080 . After clicking on the link, you should be taken to GitHub, and presented with a dialog that looks something like this:   If you trust yourself, click  Authorize App . Wuh-oh! Vert.x spits out a 500 error (with the message  callback route is not configured ). What gives?!  Well, remember when we specified a Callback URL to be  callback ? We didn't provide a route for it, so GitHub doesn't know where to drop the user after they authorize the app. Let's fix that now!",
            "title": "Accepting user authorization"
        },
        {
            "location": "/oauth2/github/#providing-a-callback",
            "text": "In the  Server  class you don't need to know the internal of the OAuth2 protocol, the  OAuth2AuthHandler  can do it for if you configure the protection as:  router . route ( \"/protected\" ). handler ( \n   OAuth2AuthHandler . create ( authProvider ) \n     // we now configure the oauth2 handler, \n     // it will setup the callback handler \n     // as expected by your oauth2 provider. \n     . setupCallback ( router . route ( \"/callback\" )) \n     // for this resource we require that \n     // users have the authority to retrieve \n     // the user emails \n     . addAuthority ( \"user:email\" ));   After a successful app authentication, GitHub provides a temporary  code  value. This code is then  POST ed back to GitHub in exchange for an  access_token  which is in turn translated to a  User  instance in your vert.x application. All this is taken care for you by the handler.",
            "title": "Providing a callback"
        },
        {
            "location": "/oauth2/github/#checking-granted-scopes",
            "text": "Before the  User  object is handled to you, if your handler was configured with  authorities  they will be first checked. If they are not present then they the whole process is aborted with an  Authorization  error.  However you might want to assert for other granted authorities, in this case you would:  ctx . user () \n   . isAuthorised ( \"some:authority\" ,   res   ->   { \n     if   ( res . failed ())   { \n       // some error handling here... \n     }   else   { \n       if   ( res . result ())   { \n         // is authorized! \n       }   else   { \n         // is not authorized! \n       } \n     } \n   });",
            "title": "Checking granted scopes"
        },
        {
            "location": "/oauth2/github/#making-authenticated-request",
            "text": "At last, with this access token, you'll be able to make authenticated requests as the logged in user:  // we cast the user to a specialized implementation  AccessToken   user   =   ( AccessToken )   ctx . user ();  // retrieve the user profile, this is a common feature  // but not from the official OAuth2 spec  user . userInfo ( res   ->   { \n   if   ( res . failed ())   { \n     // request didn't succeed because the token was revoked so we \n     // invalidate the token stored in the session and render the \n     // index page so that the user can start the OAuth flow again \n     ctx . session (). destroy (); \n     ctx . fail ( res . cause ()); \n     return ; \n   } \n\n   // the request succeeded, so we use the API to fetch the user's emails \n   final   JsonObject   userInfo   =   res . result (); \n\n   // fetch the user emails from the github API \n\n   // the fetch method will retrieve any resource and ensure the right \n   // secure headers are passed. \n   user . fetch ( \"https://api.github.com/user/emails\" ,   res2   ->   { \n     if   ( res2 . failed ())   { \n       ctx . session (). destroy (); \n       ctx . fail ( res . cause ()); \n       return ; \n     } \n\n     userInfo . put ( \"private_emails\" ,   res2 . result (). jsonArray ()); \n     // we pass the client info to the template \n     ctx . put ( \"userInfo\" ,   userInfo ); \n     // and now delegate to the engine to render it. \n     engine . render ( ctx ,   \"views\" ,   \"/advanced.hbs\" ,   res3   ->   { \n       if   ( res3 . succeeded ())   { \n         ctx . response () \n           . putHeader ( \"Content-Type\" ,   \"text/html\" ) \n           . end ( res3 . result ()); \n       }   else   { \n         ctx . fail ( res3 . cause ()); \n       } \n     }); \n   });  });   We can do whatever we want with our results. In this case, we'll just dump them straight into  advanced.hbs :  <html>\n<body>\n<p>Well, well, well, {{userInfo.login}}!</p>\n<p>\n  {{#if userInfo.email}} It looks like your public email\n  address is {{userInfo.email}}.\n  {{else}} It looks like you don't have a public email.\n  That's cool.\n  {{/if}}\n</p>\n<p>\n  {{#if userInfo.private_emails}}\n  With your permission, we were also able to dig up your\n  private email addresses:\n  {{#each userInfo.private_emails}}\n    {{email}}{{#unless @last}},{{/unless}}\n  {{/each}}\n  {{else}}\n  Also, you're a bit secretive about your private email\n  addresses.\n  {{/if}}\n</p>\n</body>\n</html>",
            "title": "Making authenticated request"
        },
        {
            "location": "/oauth2/github/#implementing-persistent-authentication",
            "text": "It'd be a pretty bad model if we required users to log into the app every single time they needed to access the web page. For example, try navigating directly to  http://localhost:8080/protected . You'll get an authentication request over and over.  What if we could circumvent the entire \"click here\" process, and just remember that, as long as the user's logged into GitHub, they should be able to access this application? Hold on to your hat, because that's  exactly what we're going to do .  Our little server above is rather simple. In order to wedge in some intelligent authentication, we're going to switch over to using sessions for storing tokens. This will make authentication transparent to the user.  This can be achived with the stock handlers so our server file would be:  package   io.acme ;  import   io.vertx.core.AbstractVerticle ;  import   io.vertx.core.json.JsonObject ;  import   io.vertx.ext.auth.oauth2.AccessToken ;  import   io.vertx.ext.auth.oauth2.OAuth2Auth ;  import   io.vertx.ext.auth.oauth2.providers.GithubAuth ;  import   io.vertx.ext.web.Router ;  import   io.vertx.ext.web.handler.* ;  import   io.vertx.ext.web.sstore.LocalSessionStore ;  import   io.vertx.ext.web.templ.HandlebarsTemplateEngine ;  public   class   Server   extends   AbstractVerticle   { \n\n   private   static   final   String   CLIENT_ID   = \n     System . getEnv ( \"GITHUB_CLIENT_ID\" ); \n   private   static   final   String   CLIENT_SECRET   = \n     System . getEnv ( \"GITHUB_CLIENT_SECRET\" ); \n\n   // In order to use a template we first need to \n   // create an engine \n   private   final   HandlebarsTemplateEngine   engine   = \n     HandlebarsTemplateEngine . create (); \n\n   @Override \n   public   void   start ()   throws   Exception   { \n     // To simplify the development of the web components \n     // we use a Router to route all HTTP requests \n     // to organize our code in a reusable way. \n     final   Router   router   =   Router . router ( vertx ); \n     // We need cookies and sessions \n     router . route () \n       . handler ( CookieHandler . create ()); \n     router . route () \n       . handler ( SessionHandler . create ( LocalSessionStore . create ( vertx ))); \n     // Simple auth service which uses a GitHub to \n     // authenticate the user \n     OAuth2Auth   authProvider   = \n       GithubAuth . create ( vertx ,   CLIENT_ID ,   CLIENT_SECRET ); \n     // We need a user session handler too to make sure \n     // the user is stored in the session between requests \n     router . route () \n       . handler ( UserSessionHandler . create ( authProvider )); \n     // we now protect the resource under the path \"/protected\" \n     router . route ( \"/protected\" ). handler ( \n       OAuth2AuthHandler . create ( authProvider ) \n         // we now configure the oauth2 handler, it will \n         // setup the callback handler \n         // as expected by your oauth2 provider. \n         . setupCallback ( router . route ( \"/callback\" )) \n         // for this resource we require that users have \n         // the authority to retrieve the user emails \n         . addAuthority ( \"user:email\" ) \n     ); \n     // Entry point to the application, this will render \n     // a custom template. \n     router . get ( \"/\" ). handler ( ctx   ->   { \n       // we pass the client id to the template \n       ctx . put ( \"client_id\" ,   CLIENT_ID ); \n       // and now delegate to the engine to render it. \n       engine . render ( ctx ,   \"views\" ,   \"/index.hbs\" ,   res   ->   { \n         if   ( res . succeeded ())   { \n           ctx . response () \n             . putHeader ( \"Content-Type\" ,   \"text/html\" ) \n             . end ( res . result ()); \n         }   else   { \n           ctx . fail ( res . cause ()); \n         } \n       }); \n     }); \n     // The protected resource \n     router . get ( \"/protected\" ). handler ( ctx   ->   { \n       AccessToken   user   =   ( AccessToken )   ctx . user (); \n       // retrieve the user profile, this is a common \n       // feature but not from the official OAuth2 spec \n       user . userInfo ( res   ->   { \n         if   ( res . failed ())   { \n           // request didn't succeed because the token \n           // was revoked so we invalidate the token stored \n           // in the session and render an error page \n           // so that the user can start the OAuth flow again \n           ctx . session (). destroy (); \n           ctx . fail ( res . cause ()); \n         }   else   { \n           // the request succeeded, so we use the API to \n           // fetch the user's emails \n           final   JsonObject   userInfo   =   res . result (); \n\n           // fetch the user emails from the github API \n\n           // the fetch method will retrieve any resource and \n           // ensure the right secure headers are passed. \n           user . fetch ( \"https://api.github.com/user/emails\" ,   res2   ->   { \n             if   ( res2 . failed ())   { \n               // request didn't succeed because the token \n               // was revoked so we invalidate the token stored \n               // in the session and render an error page \n               // so that the user can start the OAuth flow again \n               ctx . session (). destroy (); \n               ctx . fail ( res2 . cause ()); \n             }   else   { \n               userInfo . put ( \"private_emails\" ,   res2 . result (). jsonArray ()); \n               // we pass the client info to the template \n               ctx . put ( \"userInfo\" ,   userInfo ); \n               // and now delegate to the engine to render it. \n               engine . render ( ctx ,   \"views\" ,   \"/advanced.hbs\" ,   res3   ->   { \n                 if   ( res3 . succeeded ())   { \n                   ctx . response () \n                     . putHeader ( \"Content-Type\" ,   \"text/html\" ) \n                     . end ( res3 . result ()); \n                 }   else   { \n                   ctx . fail ( res3 . cause ()); \n                 } \n               }); \n             } \n           }); \n         } \n       }); \n     }); \n\n     vertx . createHttpServer (). requestHandler ( router :: accept ). listen ( 8080 ); \n   }  }   I hope you now can use OAuth2 on your next project!",
            "title": "Implementing \"persistent\" authentication"
        },
        {
            "location": "/contributing/",
            "text": "Contributing\n\u00b6\n\n\nInterested in contributing to the Vert.x Tutorials? Want to report a bug? Before\nyou do, please read the following guidelines.\n\n\nSubmission context\n\u00b6\n\n\nGot a question or problem?\n\u00b6\n\n\nFor quick questions there's no need to open an issue as you can reach us on\n\ngoogle groups\n.\n\n\nFound a bug?\n\u00b6\n\n\nIf you found a bug in the source code, you can help us by submitting an issue\nto the \nissue tracker\n in our GitHub repository. Even better, you can submit\na Pull Request with a fix. However, before doing so, please read the\n\nsubmission guidelines\n.\n\n\nMissing a feature?\n\u00b6\n\n\nYou can request a new feature by submitting an issue to our GitHub Repository.\nIf you would like to implement a new feature, please submit an issue with a\nproposal for your work first, to be sure that it is of use for everyone, as\nthe Material theme is highly opinionated. Please consider what kind of change\nit is:\n\n\n\n\n\n\nFor a \nmajor feature\n, first open an issue and outline your proposal so\n  that it can be discussed. This will also allow us to better coordinate our\n  efforts, prevent duplication of work, and help you to craft the change so\n  that it is successfully accepted into the project.\n\n\n\n\n\n\nSmall features and bugs\n can be crafted and directly submitted as a Pull\n  Request. However, there is no guarantee that your feature will make it into\n  the master, as it's always a matter of opinion whether if benefits the\n  overall functionality of the theme.\n\n\n\n\n\n\nSubmission guidelines\n\u00b6\n\n\nSubmitting an issue\n\u00b6\n\n\nBefore you submit an issue, please search the issue tracker, maybe an issue for\nyour problem already exists and the discussion might inform you of workarounds\nreadily available.\n\n\nWe want to fix all the issues as soon as possible, but before fixing a bug we\nneed to reproduce and confirm it. In order to reproduce bugs we will\nsystematically ask you to provide a minimal reproduction scenario using the\ncustom issue template. Please stick to the issue template.\n\n\nUnfortunately we are not able to investigate / fix bugs without a minimal\nreproduction scenario, so if we don't hear back from you we may close the issue.\n\n\nSubmitting a Pull Request (PR)\n\u00b6\n\n\nSearch GitHub for an open or closed PR that relates to your submission. You\ndon't want to duplicate effort. If you do not find a related issue or PR,\ngo ahead.\n\n\n\n\n\n\nDevelopment\n: Fork the project, make your changes in a\n  separate git branch and add descriptive messages to\n  your commits.\n\n\n\n\n\n\nBuild\n: Before submitting a pull requests, build the theme. This is a\n  mandatory requirement for your PR to get accepted, as the theme should at\n  all times be installable through GitHub.\n\n\n\n\n\n\nPull Request\n: After building the theme, commit the compiled output, push\n  your branch to GitHub and send a PR to \nvertx-tutorials:master\n. If we\n  suggest changes, make the required updates, rebase your branch and push the\n  changes to your GitHub repository, which will automatically update your PR.\n\n\n\n\n\n\nAfter your PR is merged, you can safely delete your branch and pull the changes\nfrom the main (upstream) repository.",
            "title": "Contributing"
        },
        {
            "location": "/contributing/#contributing",
            "text": "Interested in contributing to the Vert.x Tutorials? Want to report a bug? Before\nyou do, please read the following guidelines.",
            "title": "Contributing"
        },
        {
            "location": "/contributing/#submission-context",
            "text": "",
            "title": "Submission context"
        },
        {
            "location": "/contributing/#got-a-question-or-problem",
            "text": "For quick questions there's no need to open an issue as you can reach us on google groups .",
            "title": "Got a question or problem?"
        },
        {
            "location": "/contributing/#found-a-bug",
            "text": "If you found a bug in the source code, you can help us by submitting an issue\nto the  issue tracker  in our GitHub repository. Even better, you can submit\na Pull Request with a fix. However, before doing so, please read the submission guidelines .",
            "title": "Found a bug?"
        },
        {
            "location": "/contributing/#missing-a-feature",
            "text": "You can request a new feature by submitting an issue to our GitHub Repository.\nIf you would like to implement a new feature, please submit an issue with a\nproposal for your work first, to be sure that it is of use for everyone, as\nthe Material theme is highly opinionated. Please consider what kind of change\nit is:    For a  major feature , first open an issue and outline your proposal so\n  that it can be discussed. This will also allow us to better coordinate our\n  efforts, prevent duplication of work, and help you to craft the change so\n  that it is successfully accepted into the project.    Small features and bugs  can be crafted and directly submitted as a Pull\n  Request. However, there is no guarantee that your feature will make it into\n  the master, as it's always a matter of opinion whether if benefits the\n  overall functionality of the theme.",
            "title": "Missing a feature?"
        },
        {
            "location": "/contributing/#submission-guidelines",
            "text": "",
            "title": "Submission guidelines"
        },
        {
            "location": "/contributing/#submitting-an-issue",
            "text": "Before you submit an issue, please search the issue tracker, maybe an issue for\nyour problem already exists and the discussion might inform you of workarounds\nreadily available.  We want to fix all the issues as soon as possible, but before fixing a bug we\nneed to reproduce and confirm it. In order to reproduce bugs we will\nsystematically ask you to provide a minimal reproduction scenario using the\ncustom issue template. Please stick to the issue template.  Unfortunately we are not able to investigate / fix bugs without a minimal\nreproduction scenario, so if we don't hear back from you we may close the issue.",
            "title": "Submitting an issue"
        },
        {
            "location": "/contributing/#submitting-a-pull-request-pr",
            "text": "Search GitHub for an open or closed PR that relates to your submission. You\ndon't want to duplicate effort. If you do not find a related issue or PR,\ngo ahead.    Development : Fork the project, make your changes in a\n  separate git branch and add descriptive messages to\n  your commits.    Build : Before submitting a pull requests, build the theme. This is a\n  mandatory requirement for your PR to get accepted, as the theme should at\n  all times be installable through GitHub.    Pull Request : After building the theme, commit the compiled output, push\n  your branch to GitHub and send a PR to  vertx-tutorials:master . If we\n  suggest changes, make the required updates, rebase your branch and push the\n  changes to your GitHub repository, which will automatically update your PR.    After your PR is merged, you can safely delete your branch and pull the changes\nfrom the main (upstream) repository.",
            "title": "Submitting a Pull Request (PR)"
        },
        {
            "location": "/license/",
            "text": "License\n\u00b6\n\n\nMIT License\n\n\nCopyright \u00a9 2017 Paulo Lopes\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.",
            "title": "License"
        },
        {
            "location": "/license/#license",
            "text": "MIT License  Copyright \u00a9 2017 Paulo Lopes  Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.",
            "title": "License"
        }
    ]
}